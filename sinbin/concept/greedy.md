# 4.그리디(Greedy) 알고리즘

그리디 알고리즘은 최적 화 문제를 해결하는 문제이다. 최적화(optimization)문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소)해를 찾는 문제이다. 

# 4.1. 동전 거스름돈

[챕터 1](https://www.notion.so/1-222bd19b0d2b8065acd1d92682517179?pvs=21), 1.3에서 언급한 문제

## 핵심 아이디어

남은 액수를 초과하지 않는 조건하에 가장 큰 액면의 동전을 취하는 것

→가장 큰 액면의 동전을 취함으로서, 작은 액면의 동전이 얼마나 생길지는 고려하지 않음

→ 그리디 알고리즘의 근시안적인 특성

→5장에서 어떤 경우 에도 최적해를 찾는 동전 거스름돈을 위한 동적 계획 알고리즘을 소개 하고 있음

# 4.2. 최소 신장 트리(Minimn Spanning Tree)

주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시킨 트리들 중 간선들의 가중치 합이 최소인 트리를 말한다.

## 4.2.1. 크루스칼(Kruskasl) 알고리즘

### 4.2.1.1. 핵심 아이디어

1. 간선 정렬
2. 가중치가 가장 작은 간선이 사이클을 만들지 않을때만, 그 간선을 추가 시킨다.

```c
	입력 : 가중치 그래프 G=(V,E),|V|=n(점의 수),|E|=m(간선의 수)
	출력 : 최소 신장 트리 T
	
	가중치의 오름차순 순으로 간선들을 정렬한다.
	정렬된 간선 리스트를 L이라고 한다.
	T=Ø //트리 T를 초기화 시킨다.
	while(T의 간선수<n-1){
		L에서 가장 작은 가중치를 가진 간선e를 가져오고, e를 L에서 제거한다.
		if(간선 e가 T에 추가 되어 사이클을 만들지 않으면)
			e를 T에 추가 시킨다.
		else//e가 T에 추가 되어 사이클이 만들어지는 경우
			e를 버린다.
		}
	return 트리 T//T는 MST임
```

### 4.2.1.2. 시간 복잡도

| 단계 | 내용 | 시간복잡도 |
| --- | --- | --- |
| 1. 정렬 | 간선 가중치 기준 정렬 | `O(m log m)` |
| 2. 초기화 | 유니온파인드 초기화 | `O(1)` |
| 3. while문 | 최대 m번 반복 | `O(m)` |
| 4. 사이클 검사 | 유니온파인드 (find/union) | `O(log* m)` |

> $log*$는 매우 느리게 증가 → $log^*2=1, log^*4^2=3$
> 

결론 : $O(mlog⁡m)+O(mlog⁡^∗m)=O(m \log m )$

## 4.2.2. 프림(Prim) 알고리즘

### 4.2.2.1. 핵심 아이디어

1. 임의의 점 선택
2. (n-1)개의 현재 점에서 가장 가중치가 작은 간선을 하나씩 추가 시킨다. 

```c
	입력 : 가중치 그래프 G=(V,E),|V|=n(점의 수),|E|=m(간선의 수)
	출력 : 최소 신장 트리 T
	그래프 G에서 임의의 점 p를 시작점으로 선택하고, D[p]=0으로 놓는다.
	//D[v]는 T에 있는 점 u와 v를 연겨하는 간선의 최소 가중치를 저장한다.
	for(점 p가 아닌 각 점 v에 대하여){//배열 D의 초기화
		if(간선 (p,v)가 그래프에 있으면)
			D[v]=간선 (p,v)의 가중치
		else
			D[v]= ∞
		}
	T={p}//초기에 트리 T는 점 p만을 가진다.
	while (T에 있는 점의 수 <n){
		T에 속하지 않은 각 점 v에 대하여, 
		D[v]가 최소인 점 v_min과 연결된 간선 (u,v_min)을 T에 추가한다.
		단, u는 T에 속한 점이고, 이때 v_min도 T에 추가 된다.
		for(T에 속하지 않은 각 점 w에 대해서){
			if(간선(v_min,w)의 가중치 <D[w])
				D[w]=간선(v_min,w)의 가줓이 //D[w]를 갱신한다.
			}
		}
	return T//T는 최소 신장 트리 이다.
```

### 4.2.2.2. 시간 복잡도

|  | 내용 | 시간복잡도 |
| --- | --- | --- |
| 1️⃣ while 루프 | 총 (n - 1)회 반복 | `O(n)` |
| 2️⃣ v_min 선택 | R에 속하지 않은 정점 중 D[v] 최소값 탐색 | `O(n)` |
| 3️⃣ 인접 정점 갱신 | 최대 (n - 1)개 정점 확인 | `O(n)` |

> 🔹 D는 1차원 배열이므로, D[v] 최소값 탐색은 O(n)
> 

---

시간 복잡도

$O(n−1)×{O(n)+O(n)}=O(n2)O(n - 1) \times \{ O(n) + O(n) \} = O(n^2)$

---

# 4.3. 최단 경로 찾기(Shortest path)

대표적인 알고리즘 : Dijkstra

## 4.3.1. 핵심 아이디어

1. 주어진 출발점에서 시작한다.
2. 최단 거리가 활정되지 않은 점들 중에서 출발점으로부터 가장 가까운 점을 추가하고, 그 점의 최단 거리를 확정한다.

```c
ShortestPath(G, s)

1. 입력: 가중치 그래프 G = (V,E), |V|=n(점의 수), |E|=m(간선의 수)
   출력: 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리를 저장한 배열 D
   배열 D를 ∞로 초기화시킨다. 단, D[s] = 0으로 초기화한다.
   // 배열 D[v]에는 출발점 s로부터 점 v까지의 거리가 저장된다.

2. while (s로부터의 최단거리가 확정되지 않은 점이 있으면) {
3.   현재까지 s로부터 최단 거리가 확정되지 않은 각 점 v에 대해서 
		 최소의 D[v]의 값을 가진 점 v_min을 선택하고, 출발점 s로부터
		 점 v_min까지의 최단 거리 D[v_min]을 확정시킨다.
4.   s로부터 현재보다 짧은 거리로 점 v_min을 통해 
		 우회 가능한 각 점 w에 대해서 D[w]를 갱신한다.
5.   return D

}
```

## 4.3.2. 시간 복잡도(배열 기반)

| 항목 | 내용 | 시간복잡도 |
| --- | --- | --- |
| 1️⃣ while 루프 | 정점 수만큼 반복 (n-1회) | `O(n)` |
| 2️⃣ v_min 선택 | D 배열에서 최소값 찾기 | `O(n)` |
| 3️⃣ 인접 정점 D[w] 갱신 | 최대 (n-1)개 확인 | `O(n)` |

총 시간 복잡도

$(n−1)×[{O(n)+O(n)}]= O(n^2)$

---

힙자료 구조사용시 

| 자료구조 | v_min 선택 시간 | 전체 복잡도 |
| --- | --- | --- |
| 🟦 배열 | O(n) | `O(n²)` |
| 🟦 **피보나치 힙** | O(1) amortized | `O(n log n + m)` |

> 여기서 n은 정점 수, m은 간선 수
> 

---

# 4.4. 부분 배낭(Fractional Knasack) 문제

## 4.4.1. 문제 정의

- 총 n개의 물건이 있음
- 각 물건은 무게 와 가치를 가짐
- 용량이 제한된 배낭 안에 물건을 넣을 수 있음
- 각 물건을 부분적으로 나누어 담을 수 있음
    
    → 예: 밀가루, 액체, 분말 같은 형태를 상상하면 이해 쉬움
    

**목표 : 배낭에 담는 물건의 총 가치를 최대로 하라**

## 4.4.2. 핵심 아이디어

1. 단위 무게당 가장 값나가는 물건을 배낭에 넣는다.
2. 그 다음으로 값나가는 물건을 통째로 넣을 수 없으면 부분적으로 넣는다.

```c
1. 각 물건의 단위 무게당 가치를 계산한다.
2. 단위 무게당 가치 기준으로 물건을 내림차순 정렬한다.
3. 초기화: L = [], w = 0, v = 0

4. while ((w + x.무게) ≤ C):  // 아직 담을 수 있는 경우
    x를 L에 추가한다
    w = w + x.무게
    v = v + x.가치
    x를 리스트 S에서 제거한다

5. if ((C - w) > 0):  // 남은 용량이 있다면
    x의 일부 (C - w)만큼 L에 추가한다
    v = v + (C - w) × x의 단위 가치

6. return L, v

```

## 4.4.3. 시간 복잡도

1. line 1에서 n개의 물건 각각의 단위 무게당 가치를 계산하는데 O(n)의 시간이 걸린다.
2. line2에서 단위 무게당 가치를 계싼하는데 O(n)이 걸리고, 이를 정렬하는데 O(nlogn)의 시간이 걸린다.
3. while루프는 n번을 넘지 않으며, 루프 내며에서는 O(1)의 시간 복잡도를 가짙다.

→ O(n)+ O(nlogn)+ nxO(1)+O(1)= Onlgn)

# 4.5. 집합 커버 문제

## 4.5.1. 문제 정의

- n개의 원소를 가진 집합인 U와 U의 부분 집합들을 원소로 하는 집합 F가 있음
- F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?

## 4.5.2. 핵심 아이디어

최적해를 찾는 대신에 최적해에 근접한 근사해(approximation solution)을 찾는다.

```c
입력: U, F={S₁}, i=1,...,n  
출력: 집합 커버 C  

C = ∅  
while (U ≠ ∅) do {  
  U의 원소들을 가장 많이 포함하고 있는 집합 Sᵢ를 F에서 선택한다.  
  U = U − Sᵢ  
  Sᵢ를 F에서 제거하고, Sᵢ를 C에 추가한다.  
}  
return C

```

## 4.5.3. 시간 복잡도

| 단계 | 설명 | 시간복잡도 |
| --- | --- | --- |
| ① | `while (U ≠ ∅)` 루프 | 최대 n번 반복 |
| ② | 루프 조건 검사 | 단순 조건 검사 |
| ③ | U와 모든 집합 Sᵢ 비교하여 최적의 Sᵢ 선택 | 매 반복마다 최대 n개의 집합 검사, 각 검사마다 최대 n개의 원소 비교 |
| ④ | U에서 Sᵢ 제거 | 원소 최대 n개 제거 |
| ⑤ | Sᵢ를 F에서 제거 및 C에 추가 | 상수 연산 |

결론

- 매 루프당: **O(n² + n + 1) = O(n²)**
- 루프 최대 n회 반복
    
    → **O(n × n²) = O(n³)**
    

# 4.6. 작업 스케줄링

## 4.6.1. 문제 정의

- 기계에서 수행되는 n개의 작업 t_1,t_2, …,t_n 이 있다.
- 작업의 수행시간이 중복되지 않도록 모든 작업을 가장 적은 수에 기계에 배정한다.

## 4.6.2. 핵심 아이디어

방법론

1. 빠른 시작 시간 작업 우선
2. 빠른 종료시간 작업 우선
3. 짧은 작업 우선
4. 긴 작업 우선

→ 1번 외의 3개의 방법은 항상 최적해를 찾을 수 있지 않다.

```c
입력: n개의 작업 t₁, t₂, ..., tₙ  
출력: 각 기계에 배정된 작업 순서  

시작시간의 오름차순으로 정렬한 작업 리스트를 L이라 하자.  
while (L ≠ ∅) {  
  L에서 가장 이른 시작시간을 가진 작업 tᵢ를 가져온다.  
  if (tᵢ를 수행할 기계가 있으면)  
    tᵢ를 수행할 수 있는 기계에 배정한다.  
  else  
    새로운 기계에 tᵢ를 배정한다.  
  tᵢ를 L에서 제거한다.  
}  
return 각 기계에 배정된 작업 순서

```

## 4.6.3. 시간 복잡도

1. n개의 작업을 정렬 → O(nlogn)
2. while루프→O(m)
    
    →작업을 L에서 가져다가 수행가능한 기계를 찾아 배정하기 때문
    
3. while루프가 수행된 총 횟수 : n번

//m은 사용 된 기계수

결론 : O(nlogn)+O(nm)

# 4.7. 허프만 압축

## 4.7.1. 핵심 아이디어

파일이 빈번히 나타나는 문자에는 짧은 이진 코드, 드물게 나타나는 문자에는 긴 이진코드를 할당한다.

```c
입력: 입력 파일의 n개의 문자에 대한 각각의 빈도수  
출력: 허프만 트리  

 각 문자에 대해 노드를 만들고, 그 문자의 빈도수를 노드에 저장한다.
 n개의 노드들 (빈도수에 대해 우선순위 큐 Q를 만든다)  
while (Q에 있는 노드 수 ≥ 2) {  
  빈도수가 가장 작은 2개의 노드(A와 B)를 Q에서 제거한다.  
  새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다.  
  N의 빈도수 = A의 빈도수 + B의 빈도수  
  노드 N을 Q에 삽입한다.  
}  
return Q // 허프만 트리의 루트를 리턴하는 것이다.

```

## 4.7.2. 시간 복잡도

1. n개의 노드를 만들고 각 빈도수를 노드에 저장한다. → O(n)
2. n개의 노드로 우선순위 큐 Q를 만든다.( 힙 사용 가정)→O(n)
3. 최소 빈도수 노드 2개를 Q에서 삭제 →O(logn)
    1. 이 계산이 while안에서 n-1번 반복됨 → 총 O(nlogn)
4. 트리의 루트 리턴→ O(1)

결론 : O(n)+O(n) +O(nlogn)+O(1) =O(nlogn)
