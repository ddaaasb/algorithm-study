> 주어진 문제의 입력을 분할아여 문제를 해결(정복) 하는 방식의 알고리즘
> 분할된 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산하여, 이들의 해를 취합하여 원래의 문제의 해를 얻는다. 더이상 문제를 분할 할 수 없을 때 까지 계속 분할한다.

부분문제들의 해를 취합하여 보다 큰 문제의 해를 구한다.

---
### 분할 정복 알고리즘의 분류
$$	
T(n) = a \cdot T\left(\frac{n}{b}\right) + \Theta(n^d)
$$
	
- #### 문제가 a개로 분할되고, 부분문제의 크기가 1/b로 감소하는 알고리즘
	- a=b=2인 경우, [[합병 정렬]], [[최근접 점의 쌍 찾기]]
	- a=3, b=2인 경우 : 큰 정수의 곱셈
	- a=4, b=2인 경우 : 큰 정수의 곱셈
	- a=7, b=2인 경우, 스트라센의 행렬 곱셈 알고리즘
- #### 문제가 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘 
	- [[퀵정렬]]
- #### 문제가 2개로 분할되나, 그중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 1/2로 감소하는 알고리즘
	- [[이진탐색]]
- #### 문제가 2개로 분할되나, 그중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘
	- [[선택 문제 알고리즘]]
- #### 부분문제의 크기가 1, 2 개씩 감소하는 알고리즘
	- [[삽입정렬]], [[피보나치 수열의 계산]]

---
### 주의할 점
- 분할정복이 부적절한 경우는 입력이 분할될 때마다 분할된 부분문제의 입력 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우이다.
	- 피보나치 문제
		- F(n) = F(n-1) + F(n-2) 로 정의 되므로 순환 호출을 사용하는 것이 자연스러워 보이나, n의 숫자로 인해서 n-1, n-2의 부분문제가 생기므로 2n-3의 연산을 해야해서 사실상 분할 후 입력 크기가 거의 2배로 늘어난다. 
			- 위 문제를 해결하기 위해 그냥 for문을 사용하면 된다.
- 취합(정복) 과정에서 연산을 할 때 연산량이 커지지 않게 조심해야한다.