# CHAPTER 4

## 그리디 알고리즘(욕심쟁이 방법, 탐욕적 방법, 탐욕 알고리즘)

1. 개념
    1. 최적화 문제를 해결하는 알고리즘
    2. (입력)데이터 간의 관계를 고려하지 않고 수행과정에서 욕심내어 최솟값 또는 최댓값을 가진 데이터를 선택 —> 근시안적 선택
2. 작동 방식
    1. 근시안적 선택으로 부분적 최적해를 찾는다.
    2. 이를 모아 문제의 최적해를 찾는다.
3. 특징
    1. 일단 한 번 선택하면 이를 절대로 번복하지 않는다. —> 선택한 것을 버리고 다른 것을 취하지 않음
    2. 단순하다.
    3. 제한적인 문제들이 그리디 알고리즘으로 해결된다.

- 최적화(optimization) 문제 : 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제

## 동전 거스름돈(Coin Change)

1. 아이디어
    1. 남은 액수를 초과하지 않는 조건하에 욕심내어 가장 큰 액면의 동전 취하기
2. 알고리즘
    
    ```jsx
    입력 : 거스름돈 액수 W
    출력 : 거스름돈 액수에 대한 최소 동전 수
    change = W, n500 = n100 = n50 = n10 = n1 = 0
    	//n500, n100, n50, n10, n1은 각각의 동전 수를 위한 변수
    while(changes >= 500)
    	change = change - 500, n500++ //500원짜리 동전 수를 1증가
    while(changes >= 100)
    	change = change - 100, n100++ //100원짜리 동전 수를 1증가
    while(changes >= 50)
    	change = change - 50, n50++   //50원짜리 동전 수를 1증가
    while(changes >= 10)
    	change = change - 10, n10++   //10원짜리 동전 수를 1증가
    while(changes >= 1)
    	change = change - 1, n1++     //1원짜리 동전 수를 1증가
    
    return(n500+n100+n50+n10+n1)
    ```
    

## 최소 신장 트리(Minimum Spanning Tree)

1. 개념
    1. 주어진 가중치 그래프에서 사이클 없이 모든 점들을 연길시킨 트리들 중 간선들의 가중치 합이 최소인 트리
2. 최소 신장 트리를 찾는 그리디 알고리즘
    1. 크루스칼(Kruskal) 알고리즘
        1. 개념
            1. 가중치가 가장 작은 간선이 사이클이 만들지 않을때만 욕심내어 그 간선을 추가
        2. 알고리즘
            
            ```jsx
            입력 : 가중치 그래프 G = (V, E), |V| = n(점의 수), |E| = m(간선의 수)
            출력 : 최소 신장 트리 T
            가중치의 오름차순으로 간선들을 정렬한다. 정렬된 간선 리스트를 L이라고 하자.
            T = 공집합 //트리 T를 초기화시킨다.
            while(T의 간선의 수 <n-1){
            		L에서 가장 작은 가중치를 가진 간선 e를 가져오고, e를 L에서 제거한다.
            		if(간선 e가 T에 추가 되어 사이클을 만들지 않으면)
            				e를 T에 추가시킨다.
            		else  //e가 T에 추가되어 사이클이 만들어지는 경우
            				e를 버린다.
            }
            return 트리 T //T는 최소 신장 트리	
            ```
            
        3. 시간복잡도
            1. Line 1에서 간석ㄴ들을 가중치로 정렬하는데 $O(m\log{m})$시간이 걸린다.
                1. m은 입력 그래프에 있는 간선의 수
            2. Line2에서는 T를 단순히 초기화 —> $O(1)$
            3. Line3~8의 while 루프는 최악의 경우 m번 수행
            4. while 루프 내에서는 L로부터 가져온 간선 e가 사이클을 만드는지 검사 —> $O(\log{m})$
            5. 크루스칼 알고리즘의 시간복잡도 —> $O(m\log{m}) + O(m\log{m}) = O(m\log{m})$
    
    1. 프림(Prim) 알고리즘
        1. 과정
            1. 주어진 가중치 그래프에서 임의의 점 하나를 선택
            2. (n-1)개의 간선을 하나씩 추가시켜 트리를 만듦
            3. 현재까지 만들어진 트리에 새로운 간선을 추가하면서 연결시킬때 욕심내어서 항상 최소의 가중치로 연결되는 간선 추가
        2. 알고리즘
            
            ```jsx
            입력 : 가중치 그래프 G = (V, E), |V| = n(점의 수), |E| = m(간선의 수)
            출력 : 최소 신장 트리 T
            그래프 G에서 임의의 점 p를 시작점으로 선택하고, D[p] = 0으로 놓는다.
            //D[v]는 T에 있는 점 u와 v를 연결하는 간선의 최소 가중치를 저장
            for(점 p가 아닌 각 점 v에 대하여){ //배열 D의 초기화
            		if(간선 (p,v)가 그래프에 있으면)
            				D[v] = 간선(p, v)의 가중치
            		else
            				D[v] = ∞
            }
            T = {p}     //초기에 트리 T는 점 p만을 가진다.
            while(T에 있는 점의 수 < n){
            		T에 속하지 않은 각 점 v에 대하여, D[v]가 최소인 점 vmin과 연결된
            		간선(u, vmin)을 T에 추가한다. 단, u는 T에 속한 점이고, 이때 점 vmin도 T에 추가된다.
            		
            		for(T에 속하지 않은 각 점 w에 대해서){
            				if(간선 (vmin,w)의 가중치 < D[w])
            						D[w] = 간선(vmin, 2)의 가중치      //D[w]를 갱신
            				}
            		}
            		return T //T는 최소 신장 트리이다.
            ```
            
        3. 시간복잡도
            1. while 루프가 (n-1)번 반복되고 1회 반복될때 line9에서 T에 속하지 않은 각 점 v에 대해, D[v]가 최소인 점 vmin을 찾는 데 걸리는 시간 —> $O(n)$
            2. 배열의 크기 = 그래프의 점의 수 = n
            3. 프림 알고리즘의 시간복잡도 = $(n-1)*O(n) = O(n^2)$

- 알고리즘의 입력은 1개의 연결성분(connected  component)으로 된 가중치 그래프

1. 크루스칼 알고리즘과 프림 알고리즘의 수행 과정 차이
    1. 크루스칼 알고리즘
        1. 크루스칼 알고리즘은 간선이 한 개씩 T에 추가
        2. n개의 점들이 각각의 트리인 상태에서 간선이 추가되면 2개의 트리가 하나로 합쳐지는 것과 같음.
        3. 위 과정 반복 —> 1개의 트리인 T를 만듦
        4. n개의 트리가 합쳐져서 1개의 트리가 되는 과정
    2. 프림 알고리즘
        1. T가 점 1개인 트리에서 시작
        2. 간선을 하나씩 추가
        3. 1개의 트리가 자라나서 신장 트리가 됨.
    
    ## 최단 경로 찾기
    
    - 최단 경로(Shortest Path) 문제는 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제
    - 대표적 알고리즘
        - 다익스트라(Dijkstra) 최단 경로 알고리즘
    
    ### 다익스트라 알고리즘
    
    - 프림 알고리즘과의 차이점
        - 프림 알고리즘은 임의의 점에서 시작하지만 다익스트라 알고리즘은 주어진 출발점에서 시작
        - 프림 알고리즘은 트리에 하나의 점(간선)을 추가시킬 때 현재 상태의 트리에서 가장 가까운 점을 추가시키지만 다익스트라 알고리즘은 출발점으로 부터 최단 거리가 확정되지 않은 점들 중에서 출발점으로부터 가장 가까운 점을 추가하고 그 점의 최단거리를 확정
        
        1. 알고리즘
            1. 입력 그래프 : 양수의 가중치 그래프로서 하나의 연결 성분(connected component)로 연결되어 있다.
            2. s : 출발점
                
                ```jsx
                입력 : 가중치 그래프 G = (V, E), |V| = n(점의 수), |E| = m(간선의 수)
                출력 : 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리를 저장한 배열 D
                배열 D를 ∞로 초기화시킨다. 단, D[s] = 0으로 초기화 한다.
                //배열 D[v]에는 출발점 s로부터 점 v까지의 거리가 저장됨
                while(s로부터의 최단 거리가 확정되지 않은 점이 있으면){
                		현재까지 s로부터 최단 거리가 확정되지 않은 각 점 v에 대해서 
                		최소의 D[v]의 값을 가진 점 vmin을 선택하고,
                		출발점 s로부터 점 vmin까지의 최단 거리 D[vmin]을 확정시킨다.
                		s로부터 현재보다 짧은 거리로 점 vmin을 통해 우회 가능한 각 점 w에 대해서
                		D[w]를 갱신한다.
                }
                return D
                ```
                
            3. 시간복잡도
                1. while 루프가 (n-1)번 반복
                    1. 1회 반복될 때 line 3에서 최소의 D[V]를 가진 점 vmin을 찾는 시간 —> $O(n)$
                    2. line 4에서 vmin에 연결된 점의 수가 최대 (n-1)이므로 D[w]를 갱신하는데 걸리는 시간 —> $O(n)$
                2. 시간 복잡도 —> $(n-1)*\{O(n)+O(n)\} = O(n^2)$
            4. 활용
                1. 맵퀘스트(Mapquest)
                2. 구글 웹사이트 지도 서비스
                3. 내비게이션
                4. 네트워크 통신
                5. 모바일 네트워크
                6. 운영연구(Operation Research)
                7. 로봇 공학
                8. 교통 공삭
                9. VLSI 디자인 분야
    
    ## 부분 배낭 문제
    
    - 배낭 (Knapsack)문제는 n개의 물건이 있고, 각 물건이 무게와 가치를 가지고 있을 때, 최대의 가치를 갖도록 한정된 용량의 배낭에 넣을 물건들을 정하는 문제
    - 특징
        - 물건을 부분적으로 담는 것 허용
    
    1. 아이디어
        1. 물건을 부분적으로 담을수 있음
        2. 최적해를 위해서 욕심내어 단위 무게당 가장 값나가는 물건을 배낭에 넣는다.
        3. 계속해서 그 다음 값나가는 물건 넣는다.
        4. 만약 그 다음으로 값나가는 물건을 통째로 넣을 수 없다면 넣을 수 있는 만큼만 부분적으로 넣는다.
    2. 알고리즘
        
        ```jsx
        입력 : n개의 물건과 각 물건의 무게와 가치, 배낭의 용량 C
        출력 : 배낭에 담은 물건 리스트 L과 배낭에 담은 물건의 가치합 v
        각 물건의 단위 무게당 가치를 계산한다.
        물건들을 단위 무게당 가치를 기준으로 내림차순 정렬하고, 정렬된 물건 리스트를 S라고 하자.
        L = ∅, w = 0, v = 0
        //L은 배낭에 담을 물건 리스트, w는 배낭에 담긴 물건들의 무게의 합
        //v는 배낭에 담긴 물건들의 가치합
        
        S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.
        while((w + x의 무게) <= C){
        		x를 L에 추가시킨다.
        		w = w + x의 무게
        		v = v + x의 가치
        		x를 S에서 제거한다.
        		S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.
        }
        if((C-w)>0){//배낭에 물건을 부분적으로 더 담을 여유가 있으면
        	물건 x를 (C-w)만큼만 L에 추가한다.
        	v = v + (C - w)만큼의 x의 가치
        }
        return L, v
        ```
        
    3. 시간 복잡도
        1. line 1에서 n개의 물건 각각의 단위 무게당 가치를 계산하는데 걸리는 시간 —> $O(n)$
        2. line2에서 물건의 단위 무게당 가치에 대해서 내림차순 정렬 —> $O(n\log{n})$
        3. line 5~10의 while루프 수행은 n번을 넘지 않으며 내부 수행은 O(1)이 걸린다.
        4. line 11~14도 O(1)
        5. 시간 복잡도 : $O(n\log{n})$
    4. 0-1 배낭 문제
        1. 부분 배낭문제의 모든 조건이 같으나, 물건을 부분적으로 넣을 수 없다.
        2. 그리디 알고리즘으로 해결 불가
            1. 백트래킹
            2. 동적 계획
            3. 분기 한정
    5. 0-1 배낭 문제 활용
        1. 조합론
        2. 계산 이론
        3. 암호학
        4. 응용수학
    
    ## 집합 커버 문제
    
    1. 개념
        1. 시작점
            1. n개의 원소를 가진 집합인 U가 있고 U의 부분 집합들을 원소로 하는 집합 F가 주어질 때, F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?
        2. 개념
            1. 집합 커버(Set Cover) 문제란 F에서 선택하는 집합들의 수를 최소화 하는 문제
    
    1. 최적해 찾기
        1. F에 n개의 집합이 있다고 가정
        2. 단순한 방법
            1. F에 있는 집합의 모든 조합을 하나씩 합집합하여 U가 되는지 확인
            2. 이후 최소인 것 찾기
        3. 한계
            1. n이 커지면 실질적으로 최적해 찾기가 불가능
            2. 한계 극복 방법
                1. 최적해에 근접합 근사해 찾기(appproximation solution)
    2. 알고리즘
        1. 
        
        ```jsx
        입력 : U, F={Si}, i=1, ..., n
        출력 : 집합 커버 C
        C = ∅
        while(U != ∅) do {
        		U의 원소들을 가장 많이 포함하고 있는 집합 Si를 F에서 선택한다,
        		U = U - Si
        		Si를 F에서 제거하고, Si를 C에 추가
        }
        return C
        ```
        
    3. 시간복잡도
        1. while루프가 수행되는 횟수 —> 최대 n번
            1. 루프가 한 번 수행될 때마다 집합 U의 원소가 한 개씩만 커버된다면 최악의 경우 n번 수행
        2. 루프 1번의 시간 복잡도
            1. Line 2의 루프조건 검사 —> O(1)
            2. Line 3의 Si들의 수가 최대 n이라면 각 Si와 U의 비교는 O(n) —> $O(n^2)$
            3. Line 4에서 집합 U에서 집합 Si의 원소를 제거하는 것 —> $O(n)$
            4. Line 5에서는 Si를 F에서 제거, Si를 C에 추가 —> $O(1)$
            5. 최종 시간 복잡도
                1. $O(n^2)$
    4. 응용
        1. 도시 계획(City Planning)에서 공공기관 배치
        2. 경비 시스템
        3. 컴퓨터 바이러스
        4. 대기업의 구매 업체 선정
        5. 기업의 경력 직원 고용
        6. 비행기 조종사 스케줄링(Flight Crew Scheduling)
        7. 조립 라인 균형화(Assembly Line Balancing)
        8. 정보 검색(Information Retrieval)
    
    ## 작업 스케줄링
    
    1. 개념
        1. 기계에서 수행되는 n개의 작업 t1, t2, …, tn
        2. 각 작업은 시작 시간과 종료 시간이 존재
        3. 작업 스케줄링(Task Scheduling)은 문제의 작업 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정
    2. 아이디어
        1. 빠른 시작시간 작업을 우선(Earliest start time first) 배정
        2. 빠른 종료시간 작업을 우선(Earliest finish time first) 배정
        3. 짧은 작업을 우선(Shortest job first) 배정
        4. 긴 작업을 우선(Longest job first) 배정
    3. 알고리즘
        1. 
        
        ```jsx
        입력 : n개의 작업 t1, t2, ..., tn
        출력 : 각 기계에 배정된 작업 순서
        시작 시간의 오름차순으로 정렬한 작업 리스트 : L
        while(L != ∅){
        		L에서 가장 이른 시작시간을 가진 작업 ti를 가져온다
        		if(ti를 수행할 기계가 있으면)
        				ti를 수행할 수 있는 기계에 배정
        		else
        				새로운 기계에 ti를 배정
        		ti를 L에서 제거
        }
        return 각 기계에 배정된 작업 순서
        ```
        
    4. 시간복잡도
        1. line 1에서 n개의 작업 정렬 —> $O(n\log{n})$
        2. while 루프에서 작업을 L에서 가져다가 수행 가능한 기계를 찾아 배정 —> $O(m)$ (m은 사용된 기계의 수)
        3. while 루프 수행 횟수 —> n번
        4. Line 2~9 —> $O(m)*n = O(mn)$
        5. 최종 : $O(n\log{n}) + O(mn)$
    5. 응용
        1. 비즈니스 프로세싱
        2. 공장 생산 공정
        3. 강의실 / 세미나룸 배정
        4. 컴퓨터 태스크 스케쥴링
    
    ## 허프만 압축
    
    1. 개념
        1. 파일에 빈번히 나타나는 문자에는 짧은 이진커드를 할당
        2. 드물게 나타나는 문자에는 긴 이진코드 할당
    2. 특징
        1. 접두부 특성(prefix property)이 존재
        2. 출현 빈도수에 기반을 둔 이진 트리 만들기 —> 이진 코드 할당 —> 허프만 코드
        3. 파일 압축을 위한 허프만 코드를 찾기위한 그리디 알고리즘
        4. 입력 파일에 대해 각 문자에 할당될 이진 코드를 추출할 이진트리인 허프만 코드 리턴
    3. 알고리즘
        1. 
        
        ```jsx
        입력 : 입력 파일의 n개의 문자에 대한 각각의 빈도수
        출력 : 허프만 트리
        각 문자에 대해 노드를 만들고, 그 문자의 빈도수를 노드에 저장한다.
        n개의 노드들의 빈도수에 대해 우선순위 큐 Q를 만든다.
        while(Q에 있는 노드수 >= 2){
        		빈도수가 가장 낮은 2개의 노드(A와 B)를 Q에서 제거한다.
        		새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다.
        		N의 빈도수 <-- A의 빈도수 + B의 빈도수
        		노드 N을 Q에 삽입한다.
        }
        return Q //허프만 트리의 루트를 리턴
        ```
        
    4. 시간복잡도
        1. Line 1 —>  n개의 노드 만들기 + 빈도수를 노드에 저장 —> $O(n)$
        2. Line 2 —> n개의 노드로 우선순위 큐 Q 만들기(힙 자료구조 이용) —> $O(n)$
        3. Line 3~7
            1. 최소 빈도수를 가진 노드 2개를 Q에서 제거하는 힙의 삭제 연산, 새노드를 Q에 삽입하는 연산 수행 —> $O(\log{n})$
            2. while 루프 (n-1)번 반복 —> $(n-1)*O(\log{n}) = O(n\log{n})$
        4. Line 8은 트리를 return 함 —> $O(1)$
        5. 최종 : $O(n\log{n})$
    5. 응용
        1. 팩스
        2. 대용량 데이터 저장
        3. 멀티미디어
        4. MP3 압축
        5. 정보이론 분야 엔트로피 계산