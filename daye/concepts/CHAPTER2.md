CHAPTER2

1. 알고리즘이란?
	가. 개념
		1) 문제를 해결하는 단계적 절차 또는 방법
		2) 입력이 주어져 있으며 알고리즘은 수행한 결과인 해(또는 답)을 출력
	나. 특성
		1) 정확성
			가) 알고리즘은 주어진 입력에 대해 올바른 해를 주어야 한다.
			나) 모든 입력에 대해 원칙적으로 올바른 답을 출력해야 한다.
		2) 수행성
			가) 알고리즘의 각 단계는 컴퓨터에서 수행이 가능하여야 한다.
			나) 애매모한 표현이 있어서는 안된다.
		3) 유한성
			가) 알고리즘은 유한 시간 내에 종료되어야 한다.
			나) 알고리즘의 수행이 끝나지 않거나 매우 오래 걸릴경우 현실적으로 해를 얻을 수 없으므로 알고리즘의 가치를 잃는다.
		4) 효율성
			가) 알고리즘은 효율적일수록 그 가치가 높다.
			나) 시간, 공간적 효율성을 갖도록 고안되어야 한다.
			다) 입력의 크기가 커질수록 그 가치를 더한다.

2. 최초의 알고리즘(유클리드의 최대 공약수 알고리즘)
	가. 개념
		1) 2개의 자연수의 최대공약수는 큰 수에서 작은 수를 뺀수와 작은수의 최대공약수와 같다.
	나. 나눗셈을 이용한 유클리드 최대 공약수 알고리즘
		Euclid(a, b)
		입력 : 정수 a, b; 단 a>=b>=0
		출력 : 최대공약수(a, b)
		if(b=0) return a
		return Euclid(b, a mod b)
	다. 순서
		1) Line1에서는 두번째 숫자 b가 0이면 큰수인 a를 최대 공약수로 return
		2) Line2에서는 b가 0이 아니면 작은 수 b와 a mod b, 즉 a를 b로 나눈 나머지를 가지고 순환 호출


3. 알고리즘의 표현 방법
	가. 말
		1) 예시
			첫카드의 숫자를 읽고 머릿속에 기억해 둔다
			다음 카드의 숫자를 읽고, 그 숫자를 머릿속의 숫자와 비교한다.
			비교 후 큰 숫자를 머릿속에 기억해 둔다.
			다음에 읽을 카드가 남아 있으면 line2로 간다.
			머릿속에 기억된 숫자가 최대 숫자이다.
	나. 의사 코드
		1) 예시
			max = A[0]
			for i  = 1 to 9
				if(A[i] > max) max = A[i]
			return max

	다. 플로차트(flowchart) --> 도식화(제한적 사용)


4. 알고리즘의 분류
	가. 분할 정복(Divide-and-Conquer)
	나. 그리디(Greedy) 알고리즘
	다. 동적 계획(Dynamic Programming) 알고리즘
	라. 근사(Approximation) 알고리즘
	마. 백트래킹(Backtracking) 기법
	바. 분기 한정(Branch-and-Bound) 기법
	사. 랜덤(Random) 알고리즘 --> 확률 개념 사용
	아. 병렬(Parallel) 알고리즘 --> 특정 환경에서 제기되는 문제들을 해결
	자. 분산(Distributed) 알고리즘
	차. 양자(Quantum) 알고리즘
	카. 유전자(Genetic) 알고리즘 --> 최적해 탐색

	문제를 해결하는 방식은 문제의 속성과 밀접한 관계가 있다. 
	--> 문제마다 더 적합한 알고리즘이 존재

	위에서 분류된 알고리즘 이외에도 이름 지어지지 못한 알고리즘도 다수 존재
	--> 유사성이 없으며 따로 분류하여 명명하기 어려움
	--> 세분화 하기에 다양함
	--> 예외적으로 문제에 기반을 두어 알고리즘을 분류하기도 함
		ex) 정렬 알고리즘, 그래프(Graph) 알고리즘, 기하(Geometry) 알고리즘


5. 알고리즘의 효율성 표현
	가. 시간복잡도(time complexity) --> 알고리즘의 수행 시간

		실제로 측정된 시간은 알고리즘을 수행하는데 여러 변수(프로그래밍 언어, 프로그래머의 숙련도) 존재 --> 객관성이 떨어짐
	
		보완방법!
		알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현

	나. 공간복잡도(space complexity)
		알고리즘이 수행되는 동안 사용되는 메모리 공간의 크기

	다. 알고리즘의 복잡도 표현 분석 방법
		1) 최악 경우 분석(worst case analysis) --> 가장 일반적 사용
		2) 평균 경우 분석(average case analysis)
			--> 입력의 확률 분포(특히 균등분포(uniform distribution)) 가정하여 분석
		3) 최선 경우 분석(best case analysis)
			--> 거의 사용 x(최적 알고리즘 고안 참고 자료로 활용)


6. 복잡도의 점근적 표기
	시간복잡도, 공간복잡도는 입력 크기에 대한 함수로 표기 --> 대부분 다항식
	다항식을 단순하게 표기하기 위하여 점근적 표기(asymptotic notation)를 사용

	ex) 3n³ - 15n² + 10n - 18 --> n³
		2n² - 8n + 3          --> n²    모두 다항식의 최고차항을 계수없이 취함
		4n + 6                --> n     + 상한, 하한, 동일한 증가율 개념 적용

	가. O(Big-Oh)-표기
		1) 개념
			복잡도의 점근적 상한

			ex) f(n) = 2n² - 8n + 3의 O-표기 = O(n²)
				상한 개념을 n이 증가함에 따라 부여
				![Asymptotic Upper Bound](output.png)
				단순화된 함수 n²에 임의의 상수 c를 곱한 cn²이 n이 증가함에 따라 
				f(n)의 상한이 된다.

			교차점 이후 상한 관계를 만족하는 어떤 양수가 존재한다면 f(n) = O(n²)으로 표기할수 있다.
			--> O-표기에는 c가 '숨겨져 있다'고 생각해도 ok

			f(n)!=O(log n), f(n)!= O(n), f(n)! = O(nlog n)
			O()속의 log n, n, nlog n 각각에 대하여 어떠한 양의 실수를 선택하여도 
			f(n) = 2n² - 8n + 3보다 크게 만들수 없기 때문이다.

			f(n) = O(n³), f(n) = O(2ⁿ)
			O()속의 n³, 2ⁿ 각각에 대하여 1과 같거나 큰 양의 상수 c를 선택하면 
			cn³ > 2n² - 8n + 3, c2ⁿ > 2n² - 8n + 3과 같은 관계가 n이 무한대로 증가함에 따라 항상 성립

	나. Ω(Big-Omega)-표기
		1) 개념
			복잡도의 점근적 하한
		
		ex) f(n) = 2n² - 8n + 3의 Ω-표기 = Ω(n²)
			--> n이 증가함에 따라 2n² - 8n + 3이 cn²보다 작을 수 없다.

		O-표기와 동일하게 Ω의 표기도 복잡도 다항식의 최고차항만을 계수없이 취하면 됨

			f(n) = Ω(log n), f(n) = Ω(n), f(n) = Ω(nlog n) --> 각각 성립
			O()속의 log n, n, nlog n 각각에 대하여 어떠한 양의 실수를 선택하여도 
			f(n) = 2n² - 8n + 3보다 작게 만들수 있기 때문이다.


			f(n) = Ω(n³), f(n) = Ω(2ⁿ) --> 성립하지 x
			Ω()속의 n³, 2ⁿ 각각에 대하여 어떤 상수 c를 선택하여도 
			cn³ < 2n² - 8n + 3, c2ⁿ < 2n² - 8n + 3과 같은 관계를 만족시킬 양의 상수 c가 존재하지 않는다.


	다. θ(Theta)-표기
		1) 개념
			복잡도의 점근적 상한과 하한이 동시에 적용되는 경우
		2) 사용하는 경우
			O-표기와 Ω-표기가 같은 경우 사용
			Ω-표기를 만족하면서 차수가 가장 높은 함수를 g(n)으로 선택
		
		f(n)은 상한 θ(g(n))과 하한 Ω(g(n))j을 동시에 만족



	복잡도는 일반적으로 O-표기를 사용! (θ-표기와 혼용하기도 함)

	- O(1)         상수 시간(constant time)
	- O(log n)     로그(대수) 시간(logarithmic time)
	- O(n)         선형 시간(linear time)
	- O(nlog n)    로그 선형 시간(log-linear time)
	- O(n²)        이차 시간(quandratic time)
	- O(n³)        3차 시간(cubic time)
	- O(2ⁿ)        지수 시간(exponential time)

7. 왜 효율적인 알고리즘이 필요한가?

	10억개의 숫자를 정렬하는 데 PC에서 걸리는 시간
	O(n²) 알고리즘 --> 300여 년
	O(nlog n) 알고리즘 --> 5분

	입력 크기가 작을 경우 어느 알고리즘을 사용해도 수행시간은 비슷
	But!
	입력이 커지면 커질수록 차이가 커짐
	--> 효율적인 알고리즘이 중요하다.