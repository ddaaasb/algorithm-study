# 03 분할 정복 알고리즘

---

<aside>
💡

분할 정복(Divide-and-Conquer) 알고리즘은 입력을 분할하여 문제를 정복하는 알고리즘이다.

</aside>

- 분할된 입력에 대해 동일한 알고리즘을 적용해 해를 계산한다.
    - 이때 분할된 입력에 대한 문제를 부분문제(subproblem)라 한다.
    - 부분문제에 대한 해를 부분해라고 한다.
    - 부분문제는 더 이상 분할할 수 없을 때까지 계속 분할한다.
- 일반적으로 부분문제들의 해를 취합하여 보다 큰 부분의 해를 구한다.
- **분할 정복 알고리즘은 분할되는 부분문제의 수와 크기에 따라 다음과 같이 분류된다:**
    - 문제가 a개로 분할되고, 부분문제의 크기가 1/b로 감소하는 알고리즘.
    - 문제가 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘. 퀵 정렬.
    - 문제가 2개로 분할되나, 그중 1개는 고려할 필요 없고, 크기가 1/2로 감소하는 알고리즘. 이진탐색.
    - 문제가 2개로 분할되나, 그중 1개는 고려할 필요 없고, 크기가 일정하지 않게 감소. 선택 문제.
    - 부분문제의 크기가 1, 2개씩 감소하는 알고리즘. 삽입 정렬, 피보나치 수의 계산.

# 3.1 합병 정렬

<aside>
💡

입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.

</aside>

```c
MergeSort(A, p, q)
입력: A[p]~A[q]
출력: 정렬된 A[p]~A[q]
if (p < q) { // 배열의 원소가 2개 이상이라면
	k = (p+q)/2
	MergeSort(A, p, k) // 앞부분 순환 호출
	MergeSort(A, k+1, q) // 뒷부분 순환 호출
	A[p]~A[k]와 A[k+1]~A[q]를 합병한다.
}
```

![image.png](image.png)

- 정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 표현되므로, 분할에서는 O(1) 시간이 소요된다.
    - 분할하는 부분은 배열의 중간 인덱스 계산과 2번의 순환 호출로 구성되어 있기 때문이다.
- 합병의 수행 시간은 입력 크기에 비례한다.
    - 2개의 정렬된 배열 A와 B의 크기가 각각 n과 m일 때, 최대 비교 횟수는 (n+m-1)이다.
    - 합병의 시간 복잡도는 O(m+n)이다.

![image.png](image%201.png)

- 합병 정렬에서 수행되는 총 비교 횟수는 각각의 합병에 대해 몇 번의 비교가 수행되었는지의 총합.
- 다만 아래와 같이 층별로 살펴보아 수행되는 총 비교 횟수를 얻을 수 있다.

![image.png](image%202.png)

| 입력 크기 | 예 | 층 |
| --- | --- | --- |
| n | 8 |  |
| n/2 | 4 | 1층 |
| n/4 | 2 | 2층 |
| n/8 | 1 | 3층 |

$$
합병\ 정렬의\ 시간복잡도=(층수)*O(n)=\log_{2}{n}*O(n)=O(n\log{n})
$$

- 대부분의 정렬 알고리즘은 입력을 위한 메모리 공간과 O(1) 크기의 메모리 공간만을 사용하며 정렬한다.
    - O(1) 크기의 메모리 공간이란 입력 크기 n과 상관 없는 크기의 공간을 의미한다. 변수, 인덱스 등.
- 합병 정렬은 합병된 결과를 저장할 곳이 필요해, 합병 정렬의 공간복잡도는 O(n)이다.
- 합병 정렬은 외부정렬의 기본이 되는 정렬이다.
    - 연결 리스트에 있는 데이터를 정렬할 때에도 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다.
    - 멀티코어 CPU와 그래픽 처리 장치의 등장을로 정렬 알고리즘을 병렬화하는 데 사용된다.

# 3.2 퀵 정렬

<aside>
💡

퀵 정렬(Quick Sort)는 정복 후 분할하는 알고리즘이다.

</aside>

<aside>
💡

피봇(pivot)이라 일컫는 배열의 원소를 기준으로 분할하고, 피봇을 그 사이에 놓는 것이다.

</aside>

- 단, 피봇은 분할된 왼편이나 오른편에 포함되지 않는다.

![image.png](image%203.png)

```c
QuickSort(A, left, right)
입력: 배열 A[left]~A[right]
출력: 정렬된 배열 A[left]~A[right]
if (left < right) {
	피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 자리를 바꾼 후,
	피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,
	피봇보다 큰 순자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
	QuickSort(A, left, p-1) // 피봇보다 작은 그룹.
	QuickSort(A, p+1, right) // 피봇보다 큰 그룹.
}
```

![KakaoTalk_20250702_105336235.jpg](KakaoTalk_20250702_105336235.jpg)

![KakaoTalk_20250702_105336235_01.jpg](KakaoTalk_20250702_105336235_01.jpg)

![image.png](image%204.png)

- 퀵 정렬의 성능은 피봇 선택이 좌우한다.
    - 피봇 선택이 항상 최악인 경우, 시간복잡도는 O(n^2)이 된다.
    - 피봇 선택이 항상 최선인 경우, 항상 1/2씩 분할하게 되며, 시간복잡도는 O(nlog_2{n})이 된다.
    - 피봇 선택이 무작위인 경우에도 시간복잡도는 O(nlog_2{n})이 된다.
- 피봇 선정 방법은 다음과 같다:
    - 무작위로 선정하는 방법.
    - 3 숫자의 중앙값으로 선정하는 방법(Median of Three).
        - 가장 왼쪽 숫자, 중간 숫자, 가장 오른쪽 숫자 중 중앙값으로 피봇을 정한다.
        
        ![image.png](image%205.png)
        
    - 중앙값들 중의 중앙값(Median of Medians).
        - 입력을 3등분하여 각 부분에서의 중앙값을 찾아서 3개 중앙값에서 중앙값을 피봇으로 삼는다.
        
        ![image.png](image%206.png)
        
- 입력의 크기가 매우 클 때, 퀵 정렬의 성능 향상을 위해 삽입 정렬이 동시에 사용되기도 한다.
    - 입력의 크기가 작을 때에는 삽입 정렬이 퀵 정렬보다 빠를 수 있다. 퀵 정렬은 순환 호출로 수행.
    - 따라서 부분문제의 크기가 작아지면 더 이상의 분할(순환호출)을 중단하고 삽입 정렬을 사용.
- 퀵 정렬은 커다란 크기의 입력에 대해 가장 좋은 성능을 보이는 정렬 알고리즘이다.

# 3.3 선택 문제

<aside>
💡

선택(Selection) 문제는 n개의 숫자들 중 k번째로 작은 숫자를 찾는 문제이다.

</aside>

- 선택 문제 해결을 위한 간단한 방법은 다음과 같다:
    - 최소 숫자를 k번 찾는다. 단, 최소 숫자를 찾은 뒤에는 입력에서 그 숫자를 제거한다.
    - 숫자들을 오름차순으로 정렬한 수, k번째 숫자를 찾는다.
- 그러나 위 알고리즘들은 각각 최악의 경우 O(kn)과 O(nlog n)의 수행 시간이 걸린다.
    - 이때 O(nlog n)은 정렬의 시간복잡도이다.
- 선택 문제는 입력이 정렬되어 있지 않으므로, 입력 숫자들 중에서 피봇을 선택해 분할한다.

![image.png](image%207.png)

- 각 그룹의 크기를 알면, k번째 작은 숫자가 어느 그룹에 있는지 알 수 있게 된다.
    - Small group에 k번째 작은 숫자가 속한 경우: k번째 작은 숫자를 Small group에서 찾는다.
    - Large group에 k번째 작은 숫자가 속한 경우: (k-|Small group|-1)번째 작은 숫자를 Large group.
        - Small group의 숫자 개수와 피봇을 고려한 수이다.
- 선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나, 그중 1개 부분문제는 고려할 필요 없다.
- 또한 부분문제의 크기가 일정하지 않은 크기로 감소하는 형태의 분할 정복 알고리즘이다.

```c
Selection(A, left, right, k)
입력: A[left]~A[right]와 k, 단, 1<=k<=|A|, |A|=right-left+1
출력: A[left]~A[right]에서 k번째 작은 원소
피봇을 A[left]~A[right]에서 랜덤하게 선택하고, 피봇과 A[left]의 자리를 바꾼 후,
피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자는 A[left]~A[p-1]로 옮기고,
피봇보다 큰 숫자는 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
S = (p-1)-left+1 // S = Small group의 크기
if (k <= S+1) Selection(A, left, p-1, k) // Small group에서 찾기
else if (k == S+1) return A[p] // 피봇 = k번째 작은 숫자
else Selection(A, p+1, right, k-S-1) // large group에서 찾기
```

![KakaoTalk_20250702_130716081.jpg](KakaoTalk_20250702_130716081.jpg)

![KakaoTalk_20250702_130716081_01.jpg](KakaoTalk_20250702_130716081_01.jpg)

![KakaoTalk_20250702_130716081_02.jpg](KakaoTalk_20250702_130716081_02.jpg)

- Selection 알고리즘은 분할 정복 알고리즘이기도 하지만 랜덤(random) 알고리즘이기도 하다.
    - 피봇을 랜덤하기 정하기 때문이다.
- 선택 알고리즘이 호출될 때마다 입력이 한쪽으로 치우치게 분할될 확률을 고려한 분석이 필요하다.
    - 피봇이 입력을 Small group과 Large group을 분할, 하나의 크기가 3/4 이상이면 bad(나쁜) 분할.
    - 반대의 경우 good(좋은) 분할.
    - 따라서 good 분할이 되는 피봇을 선택할 확률과 bad 분할이 되는 피봇을 선택할 확률은 같다.

![image.png](image%208.png)

- good 분할을 할 확률이 1/2이므로, 2번 분할하면 1번은 good 분할이 가능하다.
    - good 분할만 연속해 이루어졌을 때만의 시간복잡도를 구해, 2를 곱하면 평균 시간복잡도를 얻는다.

![image.png](image%209.png)

![KakaoTalk_20250702_132035130_02.jpg](KakaoTalk_20250702_132035130_02.jpg)

- 선택 알고리즘은 이진탐색과 유사한 성격을 가진다.
    - 이진탐색은 분할 과정을 진행하며 범위를 1/2로 좁혀가며 찾고자 하는 수를 탐색한다.
    - 선택 알고리즘은 피봇으로 분할하여 범위를 좁혀간다.
    - 이 알고리즘들은 부분문제들을 취합하는 과정이 별도로 필요 없다는 공통점을 지닌다.
- 선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다.
    - 데이터 분석을 위한 중앙값을 찾는데 활용된다.

# 3.4 최근접 점의 쌍 찾기

<aside>
💡

최근접 점의 쌍(Closest Pair)을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때,

거리가 가장 가까운 한 쌍이 점을 찾는 문제이다.

</aside>

![KakaoTalk_20250702_134254757.jpg](KakaoTalk_20250702_134254757.jpg)

- 최근접 점의 쌍을 찾는 간단한 방법은 모든 점에 대해 두 점 사이의 거리를 계산하는 것이다.
- 이 방식의 시간복잡도는 O(n^2)이다.
- 이보다 더 효율적인 방법은 분할 정복을 이용하는 것이다.
    1. n개의 점을 1/2로 분할하여 각각의 부분문제에서 최근접 점의 쌍을 찾는다.
    2. 2개의 부분해 중에서 짧은 거리를 가진 점의 쌍을 찾는다.

![image.png](image%2010.png)

- 그러나 2개의 부분해를 취합할 때 반드시 다음과 같은 경우를 고려해야 한다:
    - 구역을 두 개로 분할했을 때, 10이 최소 거리가 아닌 경우가 있다.
    - 이때 가른 영역에서 10 이내의 거리를 가지는 쌍이 있는지 확인해야 한다.

![image.png](image%2011.png)

- 배열에는 점들이 x-좌표의 오름차순으로 정렬되어 있고, 각 점의 y-좌표는 생략되었다.

![image.png](image%2012.png)

![image.png](image%2013.png)

- 다음 알고리즘은 문제가 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복형.
- 단, 입력 점들은 x-좌표를 기준으로 정렬되어 있다고 가정한다.

```c
입력: x-좌표의 오름차순으로 정렬된 배열 S에는 i개의 점(단, 각 점은 (x, y)로 표현)이 주어진다.
출력: S에 있는 점들 중 최근접 점의 쌍의 거리
if (i <= 3) return (2개 또는 3개의 점들 사이의 최근접 쌍)
정렬된 S를 같은 크기의 SL과 SR로 분할한다. 단, |S|가 홀수이면, |SL|=|SR|+1이 되도록 분할.
CPL = ClosestPair(SL) // CPL은 SL에서의 최근접 점의 쌍이다.
CPR = ClosestPair(SR) // CPR의 SR에서의 최근접 점의 쌍이다.
d = min{dist(CP1), dist(CPR)}일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서
이를 CPC라고 하자. 단, dist()는 두 점 사이의 거리이다.
return (CPL, CPC, CPR 중에서 거리가 가장 짧은 쌍)
```

![KakaoTalk_20250702_144555977.jpg](KakaoTalk_20250702_144555977.jpg)

![KakaoTalk_20250702_144555977_01.jpg](KakaoTalk_20250702_144555977_01.jpg)

![KakaoTalk_20250702_144555977_02.jpg](KakaoTalk_20250702_144555977_02.jpg)

- ClosestPair 알고리즘의 시간복잡도 구하기는 입력 S에 n개의 점이 있다고 가정한다.
- 알고리즘의 전처리(preprocessing) 과정으로 S의 점을 x-좌표로 정렬하는데, O(n log n)의 시간이 소요.

![KakaoTalk_20250702_145357774.jpg](KakaoTalk_20250702_145357774.jpg)

![KakaoTalk_20250702_145357774_01.jpg](KakaoTalk_20250702_145357774_01.jpg)

# 3.5 분할 정복을 적용하는 데 있어서 주의할 점

- 입력이 분할될 때마다 부분문제의 입력 크기가 분할 전 입력 크기보다 매우 커지는 경우 부적적하다.
- 피보나치 수를 구하는 식은 순환 호출로 보이나, 분할 후 입력 크기가 2배 가까이 증가한다.
    - 이 경우 분할 정복 알고리즘을 사용하는 것은 매우 부적절하다.

```c
FibNumber(n)
F[0] = 0
F[1] = 1
for i=2 to n
	F[i] = F[i-1] + F[i-2]
```

- 기하 문제들의 특성상 취합 과정이 문제 해결에 잘 부합된다:
    - 큰 정수의 곱셈.
    - 스트라센의 행렬 곱셈 알고리즘.
    - 결정적(deterministic) 선택 알고리즘.
    - 점의 쌍 찾기 문제.
    - 공제선 문제.

# 연습문제

1. 다음의 괄호 안에 알맞은 단어를 채워 넣어라.
    1. 분할 정복 알고리즘이란 주어진 문제의 입력을 분할한 (부분문제)들을 해결하여 그 해를 취합하는 방식의 알고리즘이다.
    2. 분할 정복이 부적절한 경우는 입력이 분할될 때마다 부분문제들의 크기의 합이 분할되기 전의 크기보다 큰 경우이다.
    3. 합병 정렬에서 2개의 정렬된 부분을 (합병)하는 것은 분할 정복 알고리즘의 (정복)하는 과정이다.
    4. 퀵 정렬에서는 피봇으로 (분할)하여 부분문제가 만들어지며, 별도의 (정복) 과정이 없다.
    5. 선택 문제를 해결하는 분할 정복 알고리즘은 (퀵 정렬) 알고리즘과 같이 피봇을 사용하여 (부분문제)를 만들며, 이진탐색과 같이 별도의 (정복) 과정이 필요 없다.
    6. 최근접 점의 쌍 문제를 해결하는 분할 정복 알고리즘의 (분할) 과정은 좌측, 중간, 우측 부분에서 (최근접) 점의 쌍을 찾는 것이다.
2. 다음 중 합병 정렬에 대해 맞는 것은? 단 입력 크기는 n이다.
    - 입력과 같은 크기의 보조 배열 없이 구현할 수 없다.
        - 부분문제를 정렬하고 합병하는 알고리즘인데, 이 과정에서 임시 배열을 저장할 보조 배열이 필요.
3. 다음 중 퀵 정렬을 맞게 서술한 것은?
    - 입력을 크기가 서로 다를 수 있는 두 부분으로 나누어 보조 배열 없이 정렬한다.
        - 피봇으로 분할하여 부분문제를 해결하는 것이 퀵 정렬이다.
4. 다음 중 퀵 정렬을 맞게 서술한 것은?
    - 평균 시간복잡도는 O(n log n)이고, 최선 경우도 O(n log n)이다.
        - 피봇을 기준으로 분할이 이루어지고, 다시 층별로 합병하는 과정 떄문에 일관된 시간복잡도.
5. 다음의 입력에 대해 선택 문제를 위한 분할 정복 알고리즘으로 7번째 작은 수를 찾으려고 한다. 피봇이 8일 때 오른쪽 부분에서 몇 번째 작은 수를 찾아야 하는가?
    
    
    | 8 | 1 | 15 | 9 | 13 | 16 | 3 | 14 | 6 | 4 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    - 피봇을 기준으로 정렬한 값은 아래와 같을 것이다:
        - 1, 3, 6, 4, 8, 15, 9, 13, 16, 14
    - 이때 7번째 수를 찾기 위해서는 오른쪽 부분에서 2번째 작은 수를 찾아야 한다.
6. 크기가 n인 입력을 2개로 분할하고, 각각 분할된 부분문제의 크기가 n/2이라고 가정하자. 분할 정복 알고리즘의 분할 방식으로 더 이상 분할할 수 없는 (즉, 입력 크기가 1인) 부분문제의 수를 계산하라.
    - n개. 1*n = n.
7. 크기가 n인 입력을 3개로 분할하고, 각각 분할된 부분문제의 크기가 n/2이라 가정하자. 분할 정복 알고리즘의 분할 방식으로 최대 몇 회 분할할 수 있는가? 또, 입력 크기가 1인 부분문제의 수를 계산하라.
    - 입력 크기가 1이 되는 경우 분할이 멈춘다. 따라서 아래와 같은 횟수가 최대 분할 횟수이다.
    
    $$
    \log_2{n}
    $$
    
    - 3의 제곱으로 부분문제의 수가 증가한다.
    
    $$
    3^{\log_2{n}}
    $$
    
8. 크기가 n인 입력을 a개로 분할하고, 각각 분할된 부분문제의 크기가 n/b이라고 가정하자. 분할 정복 알고리즘의 분할 방식으로 i번 분할했을 때 부분문제의 수와 부분문제의 입력 크기를 각각 계산하라.
    - 답안은 아래와 같다.
    
    $$
    a^{i}\\(n/b)^i
    $$
    
9. 크기가 n인 입력을 a개로 분할하고, 각각 분할된 부분문제의 크기가 n/b이라고 가정하자. 분할 정복 알고리즘의 분할 방식으로 최대 몇 회 분할할 수 있는가? 또, 입력 크기가 1인 부분문제의 수를 계산하라.
    - 답안은 아래와 같다.
    
    $$
    \log_b{n}\\a^{\log_b{n}}
    $$
    
10. 다음의 배열에 있는 숫자들에 대해서 합병 정렬이 수행되는 과정을 보이라.
    
    ![image.png](image%2014.png)
    
    ![KakaoTalk_20250703_094535923.jpg](KakaoTalk_20250703_094535923.jpg)
    
11. 반복적 합병(Iterative Merge) 방식으로 정렬하는 합병 정렬을 설명하고, 3.1절의 합병 정렬과의 장단점을 비교하라.
    - Iterative Merge 방식의 예제 코드는 아래와 같다.
    
    ```python
    def merge(left, right):
        """두 정렬된 리스트를 합치는 함수"""
        merged = []
        i = j = 0
    
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                j += 1
    
        # 남은 원소 합치기
        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged
    
    def iterative_merge_sort(arr):
        n = len(arr)
        size = 1  # 병합할 부분 배열 크기
    
        # 병합 단위가 배열 길이보다 커질 때까지 반복
        while size < n:
            # 병합 단위 크기만큼 배열을 나누어 병합
            for start in range(0, n, 2*size):
                mid = min(start + size, n)  # 두 번째 부분 배열 시작 인덱스
                end = min(start + 2*size, n)  # 두 번째 부분 배열 끝 인덱스
    
                # 두 부분 배열 병합
                left = arr[start:mid]
                right = arr[mid:end]
                merged = merge(left, right)
    
                # 병합된 결과를 원래 배열에 덮어쓰기
                arr[start:start+len(merged)] = merged
    
            size *= 2  # 병합 단위 2배 증가
    
        return arr
    
    # 사용 예
    arr = [38, 27, 43, 3, 9, 82, 10]
    sorted_arr = iterative_merge_sort(arr)
    print(sorted_arr)
    ```
    
    - Iterative Merge 방식은 반복문으로 병합 단위를 키워가며 배열을 정렬한다.
    - 재귀 호출을 하지 않으므로 오버헤드가 없고, 스택 제한이 있는 상황에서 사용이 자유롭다.
    - 다만 코드가 더욱 복잡하다.
12. 3.2절의 QuickSort 알고리즘의 line 2에서는 피봇을 A[left]~A[right] 중에서 선택하고, 피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다. 이러한 분할을 위해 선택한 피봇을 A[left]와 교환한 다음에 A[left]에 위치한 피봇을 이용하여 A[left+1]~A[right]를 분할(partition)하는 알고리즘을 작성하라.
    
    ```python
    def partition(A, left, right):
        pivotIndex = left  # 여기선 첫 번째 원소를 피봇으로 선택
        pivotValue = A[pivotIndex]
    
        # 피봇을 A[left]로 옮기므로 이미 제자리에 있음
        i = left + 1
    
        for j in range(left + 1, right + 1):
            if A[j] < pivotValue:
                A[i], A[j] = A[j], A[i]
                i += 1
    
        # 피봇을 자기 자리로 이동
        A[left], A[i - 1] = A[i - 1], A[left]
    
        return i - 1  # 피봇의 최종 위치 반환
    
    # 예제
    arr = [9, 3, 7, 6, 2, 8]
    pivot_position = partition(arr, 0, len(arr) - 1)
    print("Pivot position:", pivot_position)
    print("Partitioned array:", arr)
    ```
    
13. 문제 12에서 작성한 퀵 정렬을 위한 분할 알고리즘이 다음 입력에 대하여 수행되는 과정을 보이라. 단, 가장 왼쪽 원소인 A[0]에 있는 8이 피봇이다.
    
    ![image.png](image%2015.png)
    
    ```python
    피봇인덱스 = 0
    피봇값 = arr[피봇인덱스]
    i = left + 1
    for j in range(left+1, right+1):
    	if arr[j] < 피봇값:
    		arr[i], arr[j] = arr[j], arr[i]
    		i += 1
    arr[left], arr[i-1] = arr[i-1], arr[left]
    return i-1
    ```
    
14. 퀵 정렬 알고리즘의 피봇이 랜덤하게 정해진다는 가정하에 퀵 정렬 알고리즘의 평균 경우 시간복잡도가 O(nlogn)임을 보이라.
    - 시간복잡도는 알고리즘의 연산 횟수로 정해진다.
    - 피봇이 배열을 평균적으로 절반에 가깝게 분할하게 된다.
    - 각 층에서 O(n) 연산이 필요하나 층 개수는 log n이 된다.
    - 따라서 전체의 시간복잡도는 O(n logn )이다.
15. 다음 배열의 A[5]~A[11]에 대해 QuickSort 알고리즘이 단계별로 수행된 결과를 보이라. 단 피봇을 A[11]에 있는 14이다.
    
    ![image.png](image%2016.png)
    
    - 답안은 다음과 같다.
    
    ![image.png](image%2017.png)
    
16. Selection 알고리즘의 line 1에서 피봇을 입력에서 랜덤하게 정하기 때문에 피봇이 입력 배열을 너무 한쪽으로 치우치게 분할할 수도 있다. 즉, |Small group| << |Large group| 또는 |Small group| >> |Large group|인 경우, 알고리즘의 수행 시간이 길어지는 이유를 예를 들어 설명하라.
    - 피봇을 통한 정렬이 이루어질 때, 치우치게 분할하는 경우 병렬적 정렬에서 낭비되는 시간이 존재.
17. Selection 알고리즘의 평균 경우 시간복잡도를 위한 다음의 식을 간단히 만들어서 O(n)이 됨을 보이라.
    
    ![image.png](image%2018.png)
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    
    T(n) = O \left( n \left[ 1 + \frac{3}{4} + \left( \frac{3}{4} \right)^2 + \left( \frac{3}{4} \right)^3 + \cdots \right] \right)
    \\S = \frac{a}{1 - r} = \frac{1}{1 - \frac{3}{4}} = \frac{1}{\frac{1}{4}} = 4\\T(n) = O(n \times 4) = O(n)
    
    $$
    
18. Selection 알고리즘의 평균 경우 시간복잡도를 [부록]에 있는 연속 대치법과 마스터 정리를 사용하여 각각 O(n)임을 보이라.
    
    연속 대치법
    
    - Selection 알고리즘의 평균 경우 시간복잡도 점화식은 아래와 같다.
    
    $$
    T(n)=T(\frac{3}{4}n)+cn
    $$
    
    - 3/4을 대입해 추가 식을 얻어낸다.
    
    $$
    T(\frac{3}{4}n)=T(\frac{3}{4}*\frac{3}{4}n)+\frac{3}{4}cn\\T(n)=T(\frac{3}{4}*\frac{3}{4}n)+\frac{3}{4}cn+cn\\T((\frac{3}{4})^kn)+cn\Sigma^{\log_{4/3}{n-1}}_{i=0}(\frac{3}{4})^i
    $$
    
    - 이 합은 등비수열의 합으로 유도할 수 있다.
    
    $$
    cn(1+\frac{3}{4}+……+(\frac{3}{4})^{\infty})=4cn
    $$
    
    - 따라서 O(n)이다.
    
    마스터 정리
    
    - Selection 알고리즘의 평균 경우 시간복잡도 점화식은 아래와 같다.
    
    $$
    T(n)=T(\frac{3}{4}n)+cn
    $$
    
    - 계수를 비교한다.
    
    $$
    a=1,\ b=\frac{3}{4},\ f(n)=cn\\n^{\log_ba}=n^0=1
    $$
    
    - Case 3에 해당함을 확인할 수 있다.
    
    $$
    T(n)=\Theta(f(n))=\Theta(n)
    $$
    
19. 다음의 입력에서 9번째 작은 수를 3.3절의 Selection 알고리즘으로 수행되는 과정을 보이라.
    
    ![image.png](image%2019.png)
    
    ![KakaoTalk_20250703_160913637.jpg](KakaoTalk_20250703_160913637.jpg)
    
    - 9 이후로 피봇이 이동하는 단계가 누락되었으나 12가 맞다.
20. 다음 입력의 SR 영역에서 최근접 점의 쌍을 찾기 위해 ClosestPair 알고리즘이 수행되는 과정을 3.4절의 예제와 같이 상세히 보이라.
    
    ![image.png](image%2020.png)
    
    ![image.png](image%2021.png)
    
21. 다음의 입력에서 최근접 점의 쌍을 찾으라. 단, ClosestPair 알고리즘이 되는 과정을 상세히 보이라.
    
    ![image.png](image%2022.png)
    
    ![KakaoTalk_20250703_164657707.jpg](KakaoTalk_20250703_164657707.jpg)
    
22. 최근점 접의 쌍을 위한 ClosestPair 알고리즘의 시간복잡도를 분석하는데 line 5에서 점 하나당 최대 6개의 거리만을 계산하면 된다. 그 이유를 설명하라.
    - 문제를 이해 못함. 다음 시간에 재도전 해봄.
23. 다음의 그림에서 점 1과 점 2, 3, 4가 분할선 왼쪽에 위치하여 서로의 거리를 계산할 필요가 없으며, 점 5와 6, 7, 8도 서로의 거리를 계산할 필요가 없다. 이러한 중복 계산을 피하는 방법을 설명하라.
    
    ![image.png](image%2023.png)
    
    - 왼쪽, 오른쪽 영역에 대해 최근접 점 쌍을 찾았으므로, 서로의 거리를 계산할 필요가 없다.
    - 중복 계산을 피하기 위해, 거리 계산은 왼쪽 및 오른쪽에서 점 하나씩만 뽑아 계산한다.