# 01 알고리즘의 첫걸음

---

<aside>
💡

**알고리즘**이란 문제를 해결하기 위한 단계적인 절차를 의미한다.

</aside>

# 1.1 최대 숫자 찾기

- 주어진 순서대로 읽어가며 최대 숫자를 찾는 방법을 **순차 탐색**이라고 한다.

# 1.2 임의의 숫자 찾기

- 정렬된 데이터를 반으로 나누어 원하는 데이터를 찾는 탐색 알고리즘을 **이진 탐색**이라 한다.

# 1.3 동전 거스름돈

- 주어진 거스름돈에서 가장 적은 수의 동전을 찾는 방법은 가장 큰 액면의 동전을 계속 선택하는 것이다.
- 이러한 종류의 알고리즘을 **그리디 알고리즘**이라고 한다.

# 1.4 한붓그리기

- 한붓그리기에 대한 답안은 현재 점으로 돌아오는 사이클을 찾는 것이다.

# 1.5 미로 찾기

- 미로의 해법을 찾는 방법은 입구에서부터 실을 풀고, 그 실을 감아 돌아가는 방법이 답안이다.
- 현 위치에서 한 방향을 설정하고 오른쪽 벽을 향해 돌아가면 출구를 찾을 수 있다.

# 1.6 가짜 동전 찾기

- 동전 더미를 반으로 나누어 달고, 가벼운 쪽을 더미를 계속 반으로 나누어 저울에 다는 것이 답안이다.

# 1.7 독이 든 술단지

- 각 술단지에 이진수를 할당해, 해당 자릿수가 1인 경우 술을 마시도록 한다.
- 정확한 해설은 아래 이미지와 같다.

![image.png](image.png)

- 위 이미지에서 최소 희생자 수는 0명, 최대 희생자 수는 logN이 된다.

# 연습문제

1. 다음의 괄호 안에 알맞은 단어를 채워 넣어라.
    1. 주어진 순서에 따라 차례로 탐색하는 알고리즘을 (순차 탐색 알고리즘)이라고 한다.
    2. 이진 탐색은 (정렬된) 항목들에 대해서 (중간)에 있는 항목을 비교하여 그 결과에 따라 (같은 경우) 탐색을 마치고, 다르면 작은 항목들이 있는 부분 또는 큰 항목들이 있는 부분을 같은 방식으로 탐색한다.
    3. 동전 거스름돈 문제에서는 (액면이 큰) 동전을 항상 선택한다. 이는 (그리디) 알고리즘의 일종이다.
    4. 한붓그리기 문제를 해결하는 알고리즘의 핵심은 현재 점에서 다음으로 이동 가능한 점을 선택할 때에는 반드시 현재 점으로 돌아오는 (사이클)이 존재하여야 한다는 것이다.
    5. 가짜 동전 찾기에서 동전 더미를 (절반)으로 분할하여 저울에 달고, 가짜 동전이 있는 더미를 계속해서 (절반)으로 나누어 저울에 단다. 이는 (분할 정복) 알고리즘의 일종이다.
2. 다음에 주어진 숫자들을 순차적으로 검색하여 85와 30을 찾는데 각각 몇 번을 비교해야 하는가?
    
    
    | 45 | 60 | 90 | 20 | 75 | 85 | 35 | 10 |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    - 85를 찾는 데 6번 비교해야 한다.
    - 위 수에 30이 존재하지 않아, 8번 비교한 이후에도 30을 찾을 수 없다.
3. 다음에 주어진 숫자들 중에서 가장 큰 수와 가장 작은 수를 동시에 찾으려면 최소 몇 번의 숫자 비교가 필요한가?
    
    
    | 45 | 60 | 90 | 20 |
    | --- | --- | --- | --- |
    - 순차 탐색 알고리즘을 통해 가장 큰 수를 찾는 경우 3번의 비교가 필요하다.
    - 순차 탐색 알고리즘을 통해 가장 작은 수를 찾는 경우 3번의 비교가 필요하다.
4. 다음과 같이 숫자들이 정렬되었을 때 이진탐색으로 10을 찾으려면 몇 번 비교를 해야 10이 숫자들 중에 없는 것을 알 수 있나?
    
    
    | 15 | 20 | 25 | 30 | 40 | 55 | 65 | 80 |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    - 존재하지 않는 수 10을 찾는 경우 최악의 시간 복잡도를 갖는다.
    - 따라서 3번 비교 후 이진탐색으로 10이 존재하지 않는다는 사실을 알 수 있다.
5. 다음과 같은 동전 시스템에 대해 19원을 거슬러 받으려 할 때 가장 적은 동전의 수는?
    
    
    | 1원 동전, 2원 동전, 4원 동전, 8원 동전, 32원 동전 |
    | --- |
    - 그리디 알고리즘을 이용한다.
    - 8원 동전 2개, 2원 동전 1개, 1원 동전 1개로 도합 동전 4개이다.
6. 다음과 같은 동전 시스템에 대해 20원을 거슬러 받으려 할 때 가장 적은 동전의 수는?
    
    
    | 1원 동전, 5원 동전, 10원 동전, 16원 동전, 25원 동전 |
    | --- |
    - 그리디 알고리즘을 이용하는 경우 16원 동전 1개, 1원 동전 4개로 도합 동전 5개이다.
    - 20원은 10원 동전으로 나누어 떨어지므로, 이러한 경우에 대한 예외 알고리즘이 필요하다.
        - 이 경우 도합 동전이 2개이다.
7. 동전 64개 중에 약간 가벼운 가짜 동전 1개가 섞여 있을 때 양팔 저울로 몇 번을 달아야 가짜 동전을 찾을까?
    - 이진 트리와 같다. 6번 달면 가짜 동전을 찾을 수 있다.
8. 동전 6개 중에 약간 가벼운 가짜 동전 1개가 섞여 있을 때 양팔 저울로 몇 번을 달아야 가짜 동전을 찾을까?
    - 3/3으로 분할해 저울에 달아, 가벼운 쪽 동전 3개를 찾는다.
    - 이후 3개 중 1개씩을 저울에 단다.
        - 저울의 기울어지는 방향 또는 기울어짐의 여부로 가벼운 가짜 동전을 찾을 수 있다.
9. 동전 7개 중에 약간 가벼운 가짜 동전 1개가 섞여 있을 때 양팔 저울로 몇 번을 달아야 가짜 동전을 찾을까?
    - 3/3으로 분할해 저울에 단다.
        - 저울의 기울어지는 방향으로 가벼운 쪽 동전 3개를 찾거나, 기울어짐 여부로 바로 찾는다.
    - 가벼운 쪽 동전 3개 중 1개씩을 저울에 단다.
        - 저울의 기울어지는 방향 또는 기울어짐의 여부로 가벼운 가짜 동전을 찾을 수 있다.
10. 최대 숫자 찾기 문제에 대한 알고리즘과 다른 알고리즘을 생각해 보자.
    - 순차 탐색 말고 다른 게 있나?
11. 여러 장의 숫자 카드 중에서 가장 큰 수와 가장 작은 수를 동시에 찾기 위한 알고리즘을 생각해보자.
    - 이진 트리를 만들고 왼쪽 오른쪽 노드를 가져온다.
12. 보간탐색이 어떤 방식의 탐색인지를 조사해보자.
    
    $$
    pos = low + (x - arr [low]) * (high - low) / (arr [high] - arr [low])
    $$
    
13. 다음의 숫자들에 대해 35를 이진 탐색으로 찾는 과정을 보이라.
    
    
    | 10, 20, 25, 35, 45, 55, 60, 75, 80, 90, 95 |
    | --- |
    - 55, 25, 35.
14. 1024개의 정렬된 데이터에 대해 특정 숫자를 찾기 위해 이진탐색을 하는 데 필요한 최대 비교 횟수를 구하라.
    - 10회.
15. 순차탐색, 보간탐색, 이진탐색 중 데이터가 어떻게 주어질 때 가장 빨리 찾고, 어떤 경우에 가장 늦게 찾는지 알아보자.
    - 정렬된 데이터에서 보간탐색이 가장 빠르고, 목표가 맨 뒤에 있을 때의 순차탐색이 가장 늦는다.
16. 다음의 그래프에서 한붓그리기를 위한 궤적을 그리라.
    
    ![image.png](image%201.png)
    
17. 다음의 그래프에서는 한붓그리기를 위한 궤적을 그릴 수 없다. 그 이유를 설명하라.
    
    ![image.png](image%202.png)
    
    - 사이클이 형성되지 않기 때문이다.
18. 다음의 그래프에서 연필을 종이에서 떼지 않고 v1 에서 출발하여 모든 간선을 한 번씩 지나가며 v2까지의 궤적을 그리라.
    
    ![image.png](image%203.png)
    
19. 주어진 그래프에서 사이클을 찾는 방법을 설명하라.
    - DFS 알고리즘을 이용해 판단한다.
        - 방문한 노드가 자신의 부모 노드가 아닌 경우 사이클이 형성된다.
20. 한붓그리기가 가능한지를 검사하는 또 다른 알고리즘을 조사해보자.
    - 오일러 경로를 찾는 문제이다. 각 정점의 차수가 홀수인 것이 0개 또는 2개여야 한다.
21. 한붓그리기 문제를 모든 간선 대신 모든 점을 한 번만 방문하고 시작점으로 돌아오기 문제로 변형시킨다면, 이 새로운 문제는 헤밀토니안 사이클을 찾는 문제가 된다. 이 문제에 대한 알고리즘을 조사해 보자.
    - 백트래킹 알고리즘.
22. 다음의 미로에서 오른쪽 법칙 알고리즘을 사용하여 출구를 찾는 궤적을 그려라.
    
    ![image.png](image%204.png)
    
23. 컴퓨터 프로그래밍을 통해 미로 찾기를 해결하는 방법 2가지를 제시하라.
    - DFS.
    - BFS.
24. 만일 동전의 수가 홀수 개이거나 2로 나누다 보니 한쪽이 홀수 개 다른 한 쪽이 짝수 개가 되는 경우를 처리하는 방안을 제시하라.
    - 동전이 짝수 개가 되도록 하나를 덜고 저울에 단다.
25. 1.6절보다 더 빨리 가짜 동전을 찾는 방법을 찾아보라.
    - 위에서 제시한 방법을 사용한다.
26. 독이 든 술단지 문제에서 단지의 수가 3일 때, 몇 명의 신하가 필요한가? 단지의 수가 각각 5, 6, 7일 때에는 몇 명의 신하가 필요한가?
    - 2의 신하 수를 제곱한 것이 단지의 수보다 많으면 된다.
    - 3의 경우 2명, 5, 6, 7의 경우 3명이 필요하다.