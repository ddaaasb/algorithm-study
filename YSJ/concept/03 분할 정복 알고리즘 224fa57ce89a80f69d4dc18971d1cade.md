# 03 분할 정복 알고리즘

---

<aside>
💡

분할 정복(Divide-and-Conquer) 알고리즘은 입력을 분할하여 문제를 정복하는 알고리즘이다.

</aside>

- 분할된 입력에 대해 동일한 알고리즘을 적용해 해를 계산한다.
    - 이때 분할된 입력에 대한 문제를 부분문제(subproblem)라 한다.
    - 부분문제에 대한 해를 부분해라고 한다.
    - 부분문제는 더 이상 분할할 수 없을 때까지 계속 분할한다.
- 일반적으로 부분문제들의 해를 취합하여 보다 큰 부분의 해를 구한다.
- **분할 정복 알고리즘은 분할되는 부분문제의 수와 크기에 따라 다음과 같이 분류된다:**
    - 문제가 a개로 분할되고, 부분문제의 크기가 1/b로 감소하는 알고리즘.
    - 문제가 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘. 퀵 정렬.
    - 문제가 2개로 분할되나, 그중 1개는 고려할 필요 없고, 크기가 1/2로 감소하는 알고리즘. 이진탐색.
    - 문제가 2개로 분할되나, 그중 1개는 고려할 필요 없고, 크기가 일정하지 않게 감소. 선택 문제.
    - 부분문제의 크기가 1, 2개씩 감소하는 알고리즘. 삽입 정렬, 피보나치 수의 계산.

# 3.1 합병 정렬

<aside>
💡

입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.

</aside>

```c
MergeSort(A, p, q)
입력: A[p]~A[q]
출력: 정렬된 A[p]~A[q]
if (p < q) { // 배열의 원소가 2개 이상이라면
	k = (p+q)/2
	MergeSort(A, p, k) // 앞부분 순환 호출
	MergeSort(A, k+1, q) // 뒷부분 순환 호출
	A[p]~A[k]와 A[k+1]~A[q]를 합병한다.
}
```

![image.png](image.png)

- 정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 표현되므로, 분할에서는 O(1) 시간이 소요된다.
    - 분할하는 부분은 배열의 중간 인덱스 계산과 2번의 순환 호출로 구성되어 있기 때문이다.
- 합병의 수행 시간은 입력 크기에 비례한다.
    - 2개의 정렬된 배열 A와 B의 크기가 각각 n과 m일 때, 최대 비교 횟수는 (n+m-1)이다.
    - 합병의 시간 복잡도는 O(m+n)이다.

![image.png](image%201.png)

- 합병 정렬에서 수행되는 총 비교 횟수는 각각의 합병에 대해 몇 번의 비교가 수행되었는지의 총합.
- 다만 아래와 같이 층별로 살펴보아 수행되는 총 비교 횟수를 얻을 수 있다.

![image.png](image%202.png)

| 입력 크기 | 예 | 층 |
| --- | --- | --- |
| n | 8 |  |
| n/2 | 4 | 1층 |
| n/4 | 2 | 2층 |
| n/8 | 1 | 3층 |

$$
합병\ 정렬의\ 시간복잡도=(층수)*O(n)=\log_{2}{n}*O(n)=O(n\log{n})
$$

- 대부분의 정렬 알고리즘은 입력을 위한 메모리 공간과 O(1) 크기의 메모리 공간만을 사용하며 정렬한다.
    - O(1) 크기의 메모리 공간이란 입력 크기 n과 상관 없는 크기의 공간을 의미한다. 변수, 인덱스 등.
- 합병 정렬은 합병된 결과를 저장할 곳이 필요해, 합병 정렬의 공간복잡도는 O(n)이다.
- 합병 정렬은 외부정렬의 기본이 되는 정렬이다.
    - 연결 리스트에 있는 데이터를 정렬할 때에도 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다.
    - 멀티코어 CPU와 그래픽 처리 장치의 등장을로 정렬 알고리즘을 병렬화하는 데 사용된다.

# 3.2 퀵 정렬

<aside>
💡

퀵 정렬(Quick Sort)는 정복 후 분할하는 알고리즘이다.

</aside>

<aside>
💡

피봇(pivot)이라 일컫는 배열의 원소를 기준으로 분할하고, 피봇을 그 사이에 놓는 것이다.

</aside>

- 단, 피봇은 분할된 왼편이나 오른편에 포함되지 않는다.

![image.png](image%203.png)

```c
QuickSort(A, left, right)
입력: 배열 A[left]~A[right]
출력: 정렬된 배열 A[left]~A[right]
if (left < right) {
	피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 자리를 바꾼 후,
	피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,
	피봇보다 큰 순자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
	QuickSort(A, left, p-1) // 피봇보다 작은 그룹.
	QuickSort(A, p+1, right) // 피봇보다 큰 그룹.
}
```

![KakaoTalk_20250702_105336235.jpg](KakaoTalk_20250702_105336235.jpg)

![KakaoTalk_20250702_105336235_01.jpg](KakaoTalk_20250702_105336235_01.jpg)

![image.png](image%204.png)

- 퀵 정렬의 성능은 피봇 선택이 좌우한다.
    - 피봇 선택이 항상 최악인 경우, 시간복잡도는 O(n^2)이 된다.
    - 피봇 선택이 항상 최선인 경우, 항상 1/2씩 분할하게 되며, 시간복잡도는 O(nlog_2{n})이 된다.
    - 피봇 선택이 무작위인 경우에도 시간복잡도는 O(nlog_2{n})이 된다.
- 피봇 선정 방법은 다음과 같다:
    - 무작위로 선정하는 방법.
    - 3 숫자의 중앙값으로 선정하는 방법(Median of Three).
        - 가장 왼쪽 숫자, 중간 숫자, 가장 오른쪽 숫자 중 중앙값으로 피봇을 정한다.
        
        ![image.png](image%205.png)
        
    - 중앙값들 중의 중앙값(Median of Medians).
        - 입력을 3등분하여 각 부분에서의 중앙값을 찾아서 3개 중앙값에서 중앙값을 피봇으로 삼는다.
        
        ![image.png](image%206.png)
        
- 입력의 크기가 매우 클 때, 퀵 정렬의 성능 향상을 위해 삽입 정렬이 동시에 사용되기도 한다.
    - 입력의 크기가 작을 때에는 삽입 정렬이 퀵 정렬보다 빠를 수 있다. 퀵 정렬은 순환 호출로 수행.
    - 따라서 부분문제의 크기가 작아지면 더 이상의 분할(순환호출)을 중단하고 삽입 정렬을 사용.
- 퀵 정렬은 커다란 크기의 입력에 대해 가장 좋은 성능을 보이는 정렬 알고리즘이다.

# 3.3 선택 문제

<aside>
💡

선택(Selection) 문제는 n개의 숫자들 중 k번째로 작은 숫자를 찾는 문제이다.

</aside>

- 선택 문제 해결을 위한 간단한 방법은 다음과 같다:
    - 최소 숫자를 k번 찾는다. 단, 최소 숫자를 찾은 뒤에는 입력에서 그 숫자를 제거한다.
    - 숫자들을 오름차순으로 정렬한 수, k번째 숫자를 찾는다.
- 그러나 위 알고리즘들은 각각 최악의 경우 O(kn)과 O(nlog n)의 수행 시간이 걸린다.
    - 이때 O(nlog n)은 정렬의 시간복잡도이다.
- 선택 문제는 입력이 정렬되어 있지 않으므로, 입력 숫자들 중에서 피봇을 선택해 분할한다.

![image.png](image%207.png)

- 각 그룹의 크기를 알면, k번째 작은 숫자가 어느 그룹에 있는지 알 수 있게 된다.
    - Small group에 k번째 작은 숫자가 속한 경우: k번째 작은 숫자를 Small group에서 찾는다.
    - Large group에 k번째 작은 숫자가 속한 경우: (k-|Small group|-1)번째 작은 숫자를 Large group.
        - Small group의 숫자 개수와 피봇을 고려한 수이다.
- 선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나, 그중 1개 부분문제는 고려할 필요 없다.
- 또한 부분문제의 크기가 일정하지 않은 크기로 감소하는 형태의 분할 정복 알고리즘이다.

```c
Selection(A, left, right, k)
입력: A[left]~A[right]와 k, 단, 1<=k<=|A|, |A|=right-left+1
출력: A[left]~A[right]에서 k번째 작은 원소
피봇을 A[left]~A[right]에서 랜덤하게 선택하고, 피봇과 A[left]의 자리를 바꾼 후,
피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자는 A[left]~A[p-1]로 옮기고,
피봇보다 큰 숫자는 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
S = (p-1)-left+1 // S = Small group의 크기
if (k <= S+1) Selection(A, left, p-1, k) // Small group에서 찾기
else if (k == S+1) return A[p] // 피봇 = k번째 작은 숫자
else Selection(A, p+1, right, k-S-1) // large group에서 찾기
```

![KakaoTalk_20250702_130716081.jpg](KakaoTalk_20250702_130716081.jpg)

![KakaoTalk_20250702_130716081_01.jpg](KakaoTalk_20250702_130716081_01.jpg)

![KakaoTalk_20250702_130716081_02.jpg](KakaoTalk_20250702_130716081_02.jpg)

- Selection 알고리즘은 분할 정복 알고리즘이기도 하지만 랜덤(random) 알고리즘이기도 하다.
    - 피봇을 랜덤하기 정하기 때문이다.
- 선택 알고리즘이 호출될 때마다 입력이 한쪽으로 치우치게 분할될 확률을 고려한 분석이 필요하다.
    - 피봇이 입력을 Small group과 Large group을 분할, 하나의 크기가 3/4 이상이면 bad(나쁜) 분할.
    - 반대의 경우 good(좋은) 분할.
    - 따라서 good 분할이 되는 피봇을 선택할 확률과 bad 분할이 되는 피봇을 선택할 확률은 같다.

![image.png](image%208.png)

- good 분할을 할 확률이 1/2이므로, 2번 분할하면 1번은 good 분할이 가능하다.
    - good 분할만 연속해 이루어졌을 때만의 시간복잡도를 구해, 2를 곱하면 평균 시간복잡도를 얻는다.

![image.png](image%209.png)

![KakaoTalk_20250702_132035130_02.jpg](KakaoTalk_20250702_132035130_02.jpg)

- 선택 알고리즘은 이진탐색과 유사한 성격을 가진다.
    - 이진탐색은 분할 과정을 진행하며 범위를 1/2로 좁혀가며 찾고자 하는 수를 탐색한다.
    - 선택 알고리즘은 피봇으로 분할하여 범위를 좁혀간다.
    - 이 알고리즘들은 부분문제들을 취합하는 과정이 별도로 필요 없다는 공통점을 지닌다.
- 선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다.
    - 데이터 분석을 위한 중앙값을 찾는데 활용된다.

# 3.4 최근접 점의 쌍 찾기

<aside>
💡

최근접 점의 쌍(Closest Pair)을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때,

거리가 가장 가까운 한 쌍이 점을 찾는 문제이다.

</aside>

![KakaoTalk_20250702_134254757.jpg](KakaoTalk_20250702_134254757.jpg)

- 최근접 점의 쌍을 찾는 간단한 방법은 모든 점에 대해 두 점 사이의 거리를 계산하는 것이다.
- 이 방식의 시간복잡도는 O(n^2)이다.
- 이보다 더 효율적인 방법은 분할 정복을 이용하는 것이다.
    1. n개의 점을 1/2로 분할하여 각각의 부분문제에서 최근접 점의 쌍을 찾는다.
    2. 2개의 부분해 중에서 짧은 거리를 가진 점의 쌍을 찾는다.

![image.png](image%2010.png)

- 그러나 2개의 부분해를 취합할 때 반드시 다음과 같은 경우를 고려해야 한다:
    - 구역을 두 개로 분할했을 때, 10이 최소 거리가 아닌 경우가 있다.
    - 이때 가른 영역에서 10 이내의 거리를 가지는 쌍이 있는지 확인해야 한다.

![image.png](image%2011.png)

- 배열에는 점들이 x-좌표의 오름차순으로 정렬되어 있고, 각 점의 y-좌표는 생략되었다.

![image.png](image%2012.png)

![image.png](image%2013.png)

- 다음 알고리즘은 문제가 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복형.
- 단, 입력 점들은 x-좌표를 기준으로 정렬되어 있다고 가정한다.

```c
입력: x-좌표의 오름차순으로 정렬된 배열 S에는 i개의 점(단, 각 점은 (x, y)로 표현)이 주어진다.
출력: S에 있는 점들 중 최근접 점의 쌍의 거리
if (i <= 3) return (2개 또는 3개의 점들 사이의 최근접 쌍)
정렬된 S를 같은 크기의 SL과 SR로 분할한다. 단, |S|가 홀수이면, |SL|=|SR|+1이 되도록 분할.
CPL = ClosestPair(SL) // CPL은 SL에서의 최근접 점의 쌍이다.
CPR = ClosestPair(SR) // CPR의 SR에서의 최근접 점의 쌍이다.
d = min{dist(CP1), dist(CPR)}일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서
이를 CPC라고 하자. 단, dist()는 두 점 사이의 거리이다.
return (CPL, CPC, CPR 중에서 거리가 가장 짧은 쌍)
```

![KakaoTalk_20250702_144555977.jpg](KakaoTalk_20250702_144555977.jpg)

![KakaoTalk_20250702_144555977_01.jpg](KakaoTalk_20250702_144555977_01.jpg)

![KakaoTalk_20250702_144555977_02.jpg](KakaoTalk_20250702_144555977_02.jpg)

- ClosestPair 알고리즘의 시간복잡도 구하기는 입력 S에 n개의 점이 있다고 가정한다.
- 알고리즘의 전처리(preprocessing) 과정으로 S의 점을 x-좌표로 정렬하는데, O(n log n)의 시간이 소요.

![KakaoTalk_20250702_145357774.jpg](KakaoTalk_20250702_145357774.jpg)

![KakaoTalk_20250702_145357774_01.jpg](KakaoTalk_20250702_145357774_01.jpg)

# 3.5 분할 정복을 적용하는 데 있어서 주의할 점

- 입력이 분할될 때마다 부분문제의 입력 크기가 분할 전 입력 크기보다 매우 커지는 경우 부적적하다.
- 피보나치 수를 구하는 식은 순환 호출로 보이나, 분할 후 입력 크기가 2배 가까이 증가한다.
    - 이 경우 분할 정복 알고리즘을 사용하는 것은 매우 부적절하다.

```c
FibNumber(n)
F[0] = 0
F[1] = 1
for i=2 to n
	F[i] = F[i-1] + F[i-2]
```

- 기하 문제들의 특성상 취합 과정이 문제 해결에 잘 부합된다:
    - 큰 정수의 곱셈.
    - 스트라센의 행렬 곱셈 알고리즘.
    - 결정적(deterministic) 선택 알고리즘.
    - 점의 쌍 찾기 문제.
    - 공제선 문제.