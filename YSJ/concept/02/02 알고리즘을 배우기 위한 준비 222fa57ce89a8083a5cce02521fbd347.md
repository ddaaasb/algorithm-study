# 02 알고리즘을 배우기 위한 준비

---

# 2.1 알고리즘이란

- 알고리즘의 일반적인 특성은 다음과 같다:
    - 정확성.
    - 수행성.
    - 유한성.
    - 효율성.

# 2.2 최초의 알고리즘

- 최초의 알고리즘은 유클리드의 최대공약수 알고리즘이며, 의사 코드는 아래와 같다.

```
Euclid(a, b)
입력: 정수 a, b; 단, a>=b>=0
출력 : 최대공약수(a, b)
if (b==0) return a
return Euclid(b, a mod b)
```

# 2.3 알고리즘의 표현 방법

- 일반적으로 알고리즘은 프로그래밍 언어와 유사한 의사 코드로 표현된다.
- 플로차트 형태로 알고리즘을 표현하기도 하나, 매우 제한적으로 사용된다.

# 2.4 알고리즘의 분류

- 알고리즘은 문제의 해결 방식에 따라 다음과 같이 분류된다:
    - 분할 정복(divide-and-conquer) 알고리즘.
    - 그리디(greedy) 알고리즘.
    - 동적 계획(dynamic programming) 알고리즘.
    - 근사(approximation) 알고리즘.
    - 백트래킹(backtracking) 기법.
    - 분기 한정(branch-and-bound) 기법.

# 2.5 알고리즘의 효율성 표현

- 알고리즘의 효율성은 알고리즘의 수행 시간 또는 차지하는 메모리 공간의 크기로 표현된다:
    - 시간복잡도(time complexity).
    - 공간복잡도(space complexity).

# 2.6 복잡도의 점근적 표기

- 다음과 같은 점근적 표기를 사용한다:
    - O(BIg-Oh)-표기.
    - Ω(Big-Omega)-표기.
    - θ(Theta)-표기.
- 다음과 같은 O-표기는 시간복잡도를 위해 자주 사용된다:
    - O(1): 상수 시간(constant time).
    - O(logn): 로그(대수) 시간(logarithmic time).
    - O(n): 선형 시간(linear time).
    - O(nlogn): 로그 선형 시간(log-linear time).
    - O(n^2): 이차 시간(quadratic time).
    - O(n^3): 3차 시간(cubic time).
    - O(2^n): 지수 시간(exponential time).

# 2.7 왜 효율적인 알고리즘이 필요한가?

- 하드웨어 기술 개발보다 효율적인 알고리즘 개발이 경제적이다.

# 연습문제

1. 다음의 괄호 안에 알맞은 단어를 채워 넣어라.
    1. 알고리즘이란 (문제)를 해결하는 (단계적) 절차 또는 방법이다.
    2. 알고리즘의 일반적인 특성에는 (정확성), 수행성, (유한성), 효율성이 있다.
    3. 알고리즘은 일반적으로 (의사) 코드 형태로 표현된다.
    4. 알고리즘의 효율성은 주로 (시간복잡도)가 사용된다.
    5. 알고리즘이 수행하는 (연산) 횟수를 (입력) 크기에 대한 함수로 표현한 것을 시간복잡도라고 한다.
    6. 알고리즘의 복잡도 표현 방법에는 (최악) 경우 분석, (평균) 경우 분석, (최선) 경우 분석이 있다.
    7. 입력 크기가 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법을 점근적 표기라고 한다.
    8. O(BIg-Oh)-표기는 점근적 (상한)을 나타낸다.
    9. Ω(Big-Omega)-표기는 점근적 (하한)을 나타낸다.
    10. θ(Theta)-표기는 동일한 (증가율)을 나타낸다.
2. 다음은 알고리즘에 관한 설명이다. 다음 중 옳지 않은 것은?
    - 답 없음.
3. 다음 중 알고리즘으로 해결할 수 없는 것은?
    - 가장 맛있는 라면 끓이기.
4. 다음은 알고리즘의 시간복잡도에 관한 설명이다. 다음 중 옳은 것은?
    - 알고리즘의 시간복잡도는 출력의 점근적인 표현이다.
        - O(BIg-Oh)-표기는 점근적 (상한)을 나타낸다.
        - Ω(Big-Omega)-표기는 점근적 (하한)을 나타낸다.
        - θ(Theta)-표기는 동일한 (증가율)을 나타낸다.
5. 다음은 시간복잡도의 분석에 관한 것이다. 다음 중 옳지 않은 것은?
    - 중간 경우 분석은 모든 입력에 대해 중간 시간을 분석하며 이는 알고리즘 분석에 매우 중요한 지표로 사용된다.
        - 모든 입력을 고려하지는 않는다. 모든 가능한 입력의 평균 시간을 고려한다.
6. 다음은 점근적 표기에 관한 것이다. 다음 중 옳지 않은 것은?
    - Δ-표기는 증가율 차이를 나타낸다.
        - 값의 변화량을 나타낸다. 그게 Δ니까.
7. 만일 어떤 알고리즘의 수행시간이 아래와 같을 때, 이를 O-표기로 옳게 나타낸 것은?
    
    $$
    5n^3+4n^2(3n+n\log{n})
    $$
    
    - 답안은 아래와 같다.
    
    $$
    O(n^3\log n)
    $$
    
8. 다음에서 아래에 대한 가장 적절한 점근적 표기는?
    
    $$
    \log(n!)
    $$
    
    - 답안은 아래와 같다.
    
    $$
    Θ(n\log n)
    $$
    
9. 다음 중 맞는 것은?
    - 답 없음. 실제 답안은 아래와 같다.
    
    $$
    n+\sqrt{n}=O(n)
    $$
    
10. 다음 중 맞는 것은?
    - 답 없음. 실제 답안은 아래와 같다.
    
    $$
    n^2=O(n^2)
    $$
    
11. 다음 중 틀리게 표현된 것은? 단, logn=log_2{n}이다.
    - 답 없음. 실제 답안은 아래와 같다.
    
    $$
    n^3=\Omega(5(\log{n})^5)
    $$
    
12. 다음 중 어떤 함수가 n이 커질수록 가장 빨리 증가하는가?
    - 답안은 아래와 같다.
    
    $$
    n^{10}2^n
    $$
    
13. 다음 3개의 점근적 표기에 대해 옳게 설명한 것은?
    
    $$
    (가)\ 3n^2+n^3=O(n^2)\\(나)\ 3^n+n^3=\Omega(n^2)\\(다)\ 3n^2+n^3=\Theta(n^2)
    $$
    
    - (나)는 하한을 의미하는 식으로, 옳다.
14. 다음 중 점근적 표기 관계가 옳은 것을 모두 고르라.
    - 보기에 있는 것들을 정렬한 답안은 아래와 같다.
    
    $$
    O(1)<O(\log{n})<O(\sqrt{n})<O(n)<O(n\log{n})<O(n^2)<O(2^n)
    $$
    
15. 어느 알고리즘의 수행시간이 O(n^2)이다. 입력 크기 n=k일 때 이 알고리즘을 실제로 어떤 컴퓨터에서 수행시켜보니 40초가 걸렸다.
    1. 입력 크기가 2배이면, 죽 n=2k일 때 이 알고리즘을 같은 컴퓨터에서 수행시켜보면 몇 초가 걸리는가?
        - 160초.
    2. n=2k일 때 이 알고리즘을 2배 빠른 컴퓨터에서 수행시켜보면 몇 초가 걸리는가?
        - 80초.
    3. 이 알고리즘을 100배 빠른 컴퓨터에서 40초 동안 수행시킬 때 최대 입력 크기는?
        - 10k.
16. 어떤 알고리즘을 입력 크기가 100일 때 실제로 어떤 컴퓨터에서 실행시켜보니 5초가 걸렸다.
    1. 이 알고리즘의 시간복잡도 T(n)=n^2이라면 입력 크기가 200일 때 동일한 컴퓨터에서 이 알고리즘을 수행시키면 몇 초가 걸리는가?
        - 20초.
    2. 이 알고리즘의 시간복잡도가 T(n)=n^3이라면 입력 크기가 200일 때 동일한 컴퓨터에서 이 알고리즘을 수행히키면 몇 초가 걸리는가?
        - 40초.
17. 어떤 알고리즘을 입력 크기가 2일 때 실제로 어떤 컴퓨터에서 실행시켜보니 0.01초가 걸렸고, 입력 크기가 8일 때 40.96초 걸렸다.
    1. 이 알고리즘의 시간복잡도가 T(n)=n^k일 때 k값은?
        - 4.
    2. 이 알고리즘의 시간복잡도가 T(n)=k^n일 때 값은?
        - 8.
18. 다음은 순환 관계를 각각 O-표기로 표현한 것이다. 다음 중 옳지 않은 것을 모두 고르라.
    - 2번이 틀렸으며, 아래와 같은 과정으로 올바른 O-표기를 유도한다.
    
    $$
    T(n)=3T(n/5)+n,T(1)=1 \Rightarrow T(n)=O(n)
    $$
    
19. 다음 함수에 대해 답하라.
    
    ```
    function hello_printer(k)
    	print("Hello"), print("Hello"), print("Hello")
    	for i = 1 to k
    		print("Hello"), print("Hello"), print("Hello"), print("Hello")
    		for j = 1 to k-1
    			print("Hello"), print("Hello")
    return
    ```
    
    1. 위의 함수가 k=2일 때 “Hello”는 몇 번 출력되는가?
        - 15번.
    2. 위의 함수가 k=n일 때 “Hello”가 몇 번 출력되는지를 n의 함수로 적절히 나타낸 것은? 단, n은 양의 정수이다.
        - 답은 아래와 같다.
        
        $$
        2n^2+2n+3
        $$
        
20. 다음 함수에 대해 답하라. 단 n=2^k이고 k는 음이 아닌 정수이다.
    
    ```
    function hello_printer(a[1, n], n)
    	print("Hello")
    	if n = 0 return
    	hello_printer(a[1, n/2], n/2)
    	hello_printer(a[n/2 + 1, n], n/2)
    ```
    
    1. 배열 a의 크기가 4일 때 위의 함수가 호출되면 “Hello”는 몇 번 출력되는가?
        - 15번.
    2. 위의 함수에 대해 “Hello”가 몇 번 출력되는지를 k의 함수로 적절히 나타낸 것은?
        - 답안은 아래와 같다.
        
        $$
        2^k -1
        $$
        
21. 다음의 중첩 for-루프에 대해 답하라.
    
    ```
    for i = 1 to n
    	for j = 1 to n
    		if i + j <= n
    			print("Hello")
    ```
    
    1. n=4일 때 “Hello”는 몇 번 출력되는가?
        - 6번.
    2. 위의 함수에 대해 “Hello”가 몇 번 출력되는지를 k의 함수로 적절히 나타낸 것은?
        - 답안은 아래와 같다.
        
        $$
        n(n-1)/2
        $$
        
22. 다음의 중첩 for-루프에 대해 답하라.
    
    ```
    for i = 1 to n
    	for j = 1 to n
    		if i * j <= n
    			print("Hello")
    ```
    
    1. n=4일 때 “Hello”는 몇 번 출력되는가?
        - 3번.
    2. 위의 루프에 대해 “Hello”가 몇 번 출력되는지를 n의 점근 표기법으로 가장 적절히 나타낸 것은?
        - 답안은 아래와 같다.
        
        $$
        O(n\log{n})
        $$
        
23. 다음의 while-루프에 대해 답하라. 단, i/2는 나눗셈 후 몫의 정수만을 취한다.
    
    ```
    i = n
    	while i > 0
    		print("Hello")
    		i = i / 2
    ```
    
    1. n=4일 때 “Hello”는 몇 번 출력되는가?
        - 3번.
    2. 위의 루프에 대해 “Hello”가 몇 번 출력되는지를 n의 점근 표기법으로 가장 적절히 나타낸 것은?
        - 답안은 아래와 같다.
        
        $$
        O(\log{n})
        $$
        
24. 다음 함수에 대해 답하라.
    
    ```
    function fib(n)
    	if n <= 0
    		return 1
    	return fib(n-1) + fib(n-2)
    ```
    
    1. 위의 함수가 n=3일 때, 즉 fin(3)이 호출되면 함수가 최종적으로 반환하는 값은?
        - 5번.
    2. 위의 함수의 시간복잡도를 가장 적절히 나타낸 것은?
        - 답안은 아래와 같다.
        
        $$
        O(n\log{n})
        $$
        
25. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=6T(n/4)+n^2
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=6,\ b=4\ ,d=2\\a/b^d=6/4^2<1,\ T(n)=O(n^d)=O(n^2)
    $$
    
26. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=5T(n/5)+n^2
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=5,\ b=5,\ d=2\\a/b^d=5/5^2<1,\ T(n)=O(n^d)=O(n^2)
    $$
    
27. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=9T(n/3)+n^2
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=9,\ b=3,\ d=2\\a/b^d=9/3^2=1,\ T(n)=O(n^d\log{n})=O(n^2\log{n})
    $$
    
28. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=4T(n/2)+n^2
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=4,\ b=2\ d=2\\a/b^d=4/2^2=1,\ T(n)=O(n^d\log{n})=O(n^2\log{n})
    $$
    
29. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=4T(n/2)+n
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=4,\ b=2\ d=1\\a/b^d=4/2^1>1,\ T(n)=O(n^{\log_b{a}})=O(n^2)
    $$
    
30. 아래 식을 부록의 마스터 정리를 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=8T(n/2)+n\log{n}
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    $$
    a=8,\ b=2,\ f(n)=n\log{n}\\\log_ba=log_28=3,\ f(n)=n\log{n}=O(n^{3-i})for\ i=1\\case\ 1\\T(n)=O(n^{\log_ba})=O(n^3)
    $$
    
31. 다음의 순환 관계에 대해 부록의 귀납법을 이용하여 O-표기로 나타내라. 단, T(1)=1이다.
    
    $$
    T(n)=2T(n/2)+n,\ n>1
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    ![image.png](image.png)
    
32. 다음의 순환 관계에 대해 부록의 귀납법을 이용하여 O-표기로 나타내라. 단, T(0)=0, T(1)=1이다.
    
    $$
    T(n)=T(n-1)+n,\ n>1
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    ![image.png](image%201.png)
    
33. 다음의 순환 관계에 대해 부록의 귀납법을 이용하여 O-표기로 나타내라. 단, T(n)=1, n≤5이다.
    
    $$
    T(n)=T(n/2)+T(n/4)+n
    $$
    
    - 풀이 및 답안은 아래와 같다.
    
    ![KakaoTalk_20250701_111021828.jpg](KakaoTalk_20250701_111021828.jpg)
    
34. 360과 96의 최대공약수를 나눗셈을 이용한 유클리드 알고리즘으로 구하라.
    
    $$
    360\ mod\ 96=72\\96\ mod\ 72=24\\72\ mod\ 24=0
    $$
    
    - 최대공약수는 24이다.
35. 유클리드의 최대공약수 mod 연산 알고리즘의 시간복잡도를 O-표기로 표현하라.
    - 답안은 아래와 같다.
    
    $$
    O(\log{n})
    $$
    
36. 최대 숫자 찾기 알고리즘을 플로차트로 표현하라.
    - 답안은 아래와 같다.
    
    ![image.png](image%202.png)
    
37. 유클리드의 최대공약수 알고리즘을 플로차트로 표현하라.
    - 답안은 아래와 같다.
    
    ![image.png](image%203.png)
    
38. 임의의 숫자를 찾기 위한 순차 탐색을 의사코드로 표현하라.
    
    ```
    int i, int obj, int[] arr
    
    for (int i = 0; i < arr.length(); i++) {
    	if (obj == arr[i])
    		return i;
    }
    return -1;
    ```
    
39. 정렬된 숫자들에서 임의의 숫자를 찾기 위한 보간 탐색을 의사 코드로 표현하라.
    
    ```
    int[] arr, int n, int x
    
    low = 0
    high = n - 1
    
    while(low <= high && x >= arr[low] && x <= arr[high]) {
    	
    	// 분모 0 되는 경우 방지.
    	if (arr[high] == arr[low]) {
    		if (arr[low] == x) {
    			return low;
    		} else {
    			break;
    		}
    	}
    	
    	// 예상 위치 계산.
    	pos = low + ((x - arr[low]) * (high - low)) / (arr[high] - arr[low])
    	
    	if (arr[pos] == x) {
    		return pos;
    	} else if (arr[pos] < x) {
    		low = pos + 1;
    	} else {
    		high = pos - 1;
    	}
    }
    return -1;
    ```
    
40. 정렬된 숫자들에서 임의의 숫자를 찾기 위한 이진 탐색 알고리즘을 의사 코드로 표현하라.
    
    ```
    int[] arr, int n, int x
    
    low = 0
    high = n - 1
    
    while (low <= high) {
        mid = (low + high) / 2
    
        if (arr[mid] == x) {
            return mid;
        } else if (arr[mid] < x) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
    ```
    
41. 한붓그리기 문제를 해결하는 알고리즘을 의사 코드로 표현하라.
    - 오일러 경로를 구하는 알고리즘을 작성하라는 의미이다.

```
// 그래프는 인접 리스트로 표현, edges[v]는 정점 v의 인접 정점 리스트
// 모든 간선은 한 번만 사용할 수 있음

stack = empty stack;
path = empty list;

// 홀수 차수 정점 개수 세기
odd_count = 0;
for each vertex v in graph {
    if (degree of v is odd) {
        odd_count = odd_count + 1;
        start = v; // 홀수 차수 정점이 있으면 그 중 하나를 시작점으로
    }
}

// 시작점 선택 (홀수 차수 정점이 없으면 아무 정점이나)
if (odd_count == 0) {
    for each vertex v in graph {
        if (degree of v > 0) {
            start = v;
            break;
        }
    }
} else if (odd_count == 2) {
    // 이미 위에서 start는 홀수 차수 정점으로 할당됨
} else {
    return "No Eulerian Path";
}

stack.push(start);

while (stack is not empty) {
    v = stack.top();
    if (v has unused edges) {
        u = any unused neighbor of v;
        remove edge (v, u) from graph;
        stack.push(u);
    } else {
        path.append(stack.pop());
    }
}

// 경로는 역순이므로 뒤집어서 반환
reverse(path);
return path;
```

1. 분할 정복(Divide-and-Conquer) 알고리즘을 적용할 수 있는 문제들을 조사하라.
    - 분할 정복을 위해서는 다음 조건을 만족해야 한다:
        - 하위 문제 독립성.
        - 문제 분할 가능성.
        - 결합 효율성.
    - 이에 따라 머지 정렬 혹은 퀵 정렬, 이진 탐색 등에 사용된다.
2. 그리디(Greedy) 알고리즘을 적용할 수 있는 문제들을 조사하라.
    - 최소 신장 트리, 최단 경로 문제, 작업 스케쥴링 등.
3. 동적 계획(Dynamic Programming) 알고리즘을 적용할 수 있는 문제들을 조사하라.
    - 최적화 문제, 수열/문자열 문제, 경로 및 조합 문제 등.
4. 근사(Approximation) 알고리즘을 적용할 수 있는 문제들을 조사하라.
    - 근사 알고리즘은 NP-hard 최적화 문제를 풀기 위해 최적해에 가까운 해를 보장한다.
    - 여행하는 외판원 문제, 정점 커버 문제, 최대 컷 문제 등.
5. 랜덤(Random) 알고리즘을 적용할 수 있는 문제들을 조사하라.
    - 무작위성을 활용해 계산 효율성을 높이거나 복잡한 문제를 해결하는 기법이다.
    - 소수 판별, 행렬 곱 검증, 최소 컷 등.
6. 정렬 문제를 해결하는 알고리즘을 조사하라.
    - 버블 정렬, 선택 정렬, 삽입 정렬, 병합 정렬 등.
7. 그래프 문제에는 어떤 문제들이 있는지 조사하라.
    - DFS, BFS, MST 등.
8. 기하 문제에는 어떤 문제들이 있는지 조사하라.
    - 이차곡선 문제, 도형 간의 위치 관계, 벡터 방정식 등.
9. 최대 숫자 찾기 알고리즘의 시간복잡도를 구하라. 단, n 개의 숫자가 있다고 가정하라.
    - O(n).
10. 임의의 숫자를 찾기 위한 순차탐색의 최악 경우 시간복잡도를 구하라. 단, n개의 숫자가 있다고 가정하라.
    - O(n).
11. 임의의 숫자를 찾기 위한 순차탐색의 평균 경우 시간복잡도를 구하라. 단, n개의 숫자가 있다고 가정하라.
    - O(n).
12. 임의의 숫자를 찾기 위한 순차탐색의 최선 경우 시간복잡도를 구하라. 단, n개의 숫자가 있다고 가정하라.
    - O(1).
13. n개의 정렬된 숫자에서 임의의 숫자를 찾기 위한 보간탐색의 최악의 경우 시간복잡도를 구하라.
    - O(n).
14. n개의 정렬된 숫자에서 임의의 숫자를 찾기 위한 보간탐색의 최선/평균 경우 시간복잡도를 구하라.
    - O(log log n).
15. n개의 정렬된 숫자에서 임의의 숫자를 찾기 위한 이진탐색의 최악의 경우 시간복잡도를 구하라.
    - O(log n).
16. n개의 정렬된 숫자에서 임의의 숫자를 찾기 위한 이진탐색의 평균 경우 시간복잡도를 구하라.
    - O(log n).
17. 한붓그리기 알고리즘의 최악 경우 시간복잡도를 구하라. 단, 그래프의 정점의 수는 n이고, 간선의 수는 m이다.
    - O(m).
18. 다음의 함수를 각각 O-표기로 나타내라.
    
    $$
    10000,\ 4\log{n}-9,\ 6n-1000,\ 2n\log{n}+3n+\log{n}-7,\ 5n^2+9n-15,\\3n^3+5n-7n+15,\ 6n^9+2n^7-n^6+2n+1,\ 2^n+n^{15}+n^4-3
    $$
    
    - O(1).
    - O(log n).
    - O(n).
    - O(n log n).
    - O(n^2).
    - O(n^3).
    - O(n^9).
    - O(2^n).